dim(H2)
aa2 <- RMSE.ph2(Y2, chart1$model, X2, H2)
aa2
bb <- RMSE.ph1(chart11$model)
bb1 <- RMSE.ph2(Y2, chart11$model, X2, H2)
median(aa2$RMSE.ma)
median(bb1$RMSE.ma)
median(aa$RMSE.ma)
median(bb$RMSE.ma)
set.seed(12345)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 200
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
chart11 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, method = "LASSO", nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
aa <- RMSE.ph1(chart1$model)
aa1 <- RMSE.ph2(Y2, chart1$model, X2, H2)
bb <- RMSE.ph1(chart11$model)
bb1 <- RMSE.ph2(Y2, chart11$model, X2, H2)
aa$RMSE.ma
median(aa$RMSE.ma)
median(bb$RMSE.ma)
median(bb$RMSE.tr)
median(aa$RMSE.tr)
boxplot(aa$RMSE.tr, bb$RMSE.tr)
boxplot(aa1$RMSE.tr, bb1$RMSE.tr)
median(aa1$RMSE.tr)
median(bb1$RMSE.tr)
median(aa1$RMSE.ma)
median(bb1$RMSE.ma)
?BayesianLASSOMonitoring::rzinpoisinar3
dim(H2sim)
dim(X2sim)
H2sim
X2sim
chart2 <- Ph2BayesianLASSO.EWMA(Y2, chart1$model, lambda = 0.1, H = H2sim, X = X2sim,
Y1 = Y1[(q + w):TT1], X1 = X1[(q + w):TT1, ], H1 = H1[(q + w):TT1, ],
log = TRUE, const = 1, sta = TRUE, meanY = chart1$model$meanY, sdY = chart1$model$sdY,
Y.hat.method = "mean",
ARL0 = 360, side = "right-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE)
chart2 <- Ph2BayesianLASSO.EWMA(Y2, chart1$model, lambda = 0.1, H = H2sim, X = X2sim,
Y1 = Y1[(q + w):TT1], X1 = X1[(q + w):TT1, ], H1 = H1[(q + w):TT1, ],
log = TRUE, const = 1, sta = TRUE, meanY = chart1$model$meanY, sdY = chart1$model$sdY,
Y.hat.method = "mean",
ARL0 = 360, side = "right-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = FALSE)
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param Y0 is the initial Y
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param standardized is the flag triggering the standardization for the time series
#' @param logcc is the log transformation with continuity correction
#' @param FAP0 is the given false alarm probability
#' @param estimation.PPP is the estimation for Mu0, Phi and sigma2
#' @param nsim.PPP is the number of draws for PPP
#'
#'
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- Ph1BayesianLASSO(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
Ph1BayesianLASSO <- function(Y, w = 7, H = NULL, X = NULL, Y0 = rep(mean(Y), w - 1), q = 5,
A = diag(nrow = q + ifelse(is.null(X), 0, dim(X)[2])),
a = 0.1, b = 0.1, alpha = 0.1, beta = 0.1,
theta1 = 1, theta2 = 1, xi2 = 0.1,
method = "MonoALASSO", bound0 = Inf, boundqplus1 = 0,
nsim = 1000, by = 1, burnin = 1000, tol = 1e-10,
log = TRUE, const = 1, sta = TRUE,
Y.hat.method = "median",
cc.method = "adjusted alpha",
FAP0 = 0.3, side = "two-sided",
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
TT <- length(Y)
model <- GibbsRFLSM.count(Y, w, H, X, Y0, q,
A, a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin, tol,
log, const, sta)
Y.tr.sim <- GibbsRFLSM.sim.ph1(nsim.chart, model$Y.tr,
model$Phi, model$muq, model$sigma2,
X, model$Beta, model$Kappa,
NULL, NULL, NULL)
Y.hat.sim <- Y.tr.sim$fit
Y.tr.sim <- Y.tr.sim$Y.tr
Y.hat <- rep(NA, TT - q)
if (Y.hat.method == "median") {
for (i in 1:(TT - q)) {
Y.hat[i] <- median(Y.hat.sim[i, ])
}
sigma2hat <- median(model$sigma2)
} else if (Y.hat.method == "mean") {
Y.hat <- rowMeans(Y.hat.sim)
sigma2hat <- mean(model$sigma2)
}
sigmahat <- sqrt(sigma2hat)
lim.tr <- matrix(NA, nrow = TT, ncol = 2)
sig.tr <- lim.tr[, 1]
if (plot == TRUE) {
if (cc.method == "adjusted alpha") {
adjalpha <- adjalpha.ph1(Y.hat, sigma2hat, Y.tr.sim, FAP0, side, tol.chart)
for (i in (q + 1):TT) {
if (side == "two-sided") {
lim.tr[i, ] <- quantile(adjalpha$resi[i - q, ], c(adjalpha$adjalpha / 2, 1 - adjalpha$adjalpha / 2)) * sigmahat + Y.hat[i - q]
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- quantile(adjalpha$resi[i - q, ], c(1 - adjalpha$adjalpha)) * sigmahat + Y.hat[i - q]
} else if (side == "left-sided") {
lim.tr[i, 1] <- quantile(adjalpha$resi[i - q, ], c(adjalpha$adjalpha)) * sigmahat + Y.hat[i - q]
lim.tr[i, 2] <- Inf
}
}
} else if (cc.method == "classic") {
cc <- cc.ph1(Y.hat, sigma2hat, Y.tr.sim, FAP0, side, tol.chart)
for (i in (q + 1):TT) {
if (side == "two-sided") {
lim.tr[i, 1] <- Y.hat[i - q] - cc$cc * sigmahat
lim.tr[i, 2] <- Y.hat[i - q] + cc$cc * sigmahat
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- Y.hat[i - q] + cc$cc * sigmahat
} else if (side == "left-sided") {
lim.tr[i, 1] <- Y.hat[i - q] - cc$cc * sigmahat
lim.tr[i, 2] <- Inf
}
}
}
sig.tr <- (lim.tr[, 1] <= model$Y.tr) & (model$Y.tr <= lim.tr[, 2])
if (side == "two-sided") {
Ylim <- c(min(lim.tr, model$Y.tr, na.rm = TRUE), max(lim.tr, model$Y.tr, na.rm = TRUE))
} else if (side == "right-sided") {
Ylim <- c(min(model$Y.tr, na.rm = TRUE), max(lim.tr, model$Y.tr, na.rm = TRUE))
} else if (side == "left-sided") {
Ylim <- c(min(lim.tr, model$Y.tr, na.rm = TRUE), max(model$Y.tr, na.rm = TRUE))
}
plot(c(1, TT), Ylim, type = 'n',
main = "Phase I Chart for Transformed Moving Averages",
ylab = "Transformed Moving Averages",
xlab = "")
points(model$Y.tr, type = 'o')
points((1:TT)[which(sig.tr == FALSE)], model$Y.tr[which(sig.tr == FALSE)], col = 'red', pch = 16)
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("model" = model, "lim.tr" = lim.tr,
"sig.tr" = sig.tr, "Y.hat" = Y.hat)
out
}
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param Y0 is the initial Y
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param standardized is the flag triggering the standardization for the time series
#' @param logcc is the log transformation with continuity correction
#' @param FAP0 is the given false alarm probability
#' @param estimation.PPP is the estimation for Mu0, Phi and sigma2
#' @param nsim.PPP is the number of draws for PPP
#'
#'
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- Ph1BayesianLASSO(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
Ph2BayesianLASSO.EWMA <- function(Y, Ph1BayesianLASSO.model, lambda = 0.05, H = NULL, X = NULL,
Y1 = rep(0, dim(Ph1BayesianLASSO.model$Phi)[1] + w), X1 = NULL, H1 = NULL,
log = TRUE, const = 1, sta = TRUE, meanY = 0, sdY = 1,
Y.hat.method = "median",
cc.method = "adjusted alpha",
ARL0 = 360, side = "two-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
w <- Ph1BayesianLASSO.model$w
TT2 <- length(Y)
q <- dim(Ph1BayesianLASSO.model$Phi)[1]
Y2 <- c(Y1, Y)
TT <- length(Y2)
Y2.ma <- movaver(Y2, w)[(TT - TT2 - q + 1):TT]
if (log == TRUE) {
Y2.tr <- log(Y2.ma + const)
}
if (sta == TRUE) {
Y2.tr <- (Y2.tr - meanY) / sdY
}
Y2.tr0 <- Y2.tr[1:q]
Y2.tr1 <- Y2.tr[-c(1:q)]
Y2.tr.sim <- GibbsRFLSM.sim.ph2(max.length, nsim.chart,
Ph1BayesianLASSO.model$Phi, Ph1BayesianLASSO.model$muq, Ph1BayesianLASSO.model$sigma2,
X, Ph1BayesianLASSO.model$Beta, Ph1BayesianLASSO.model$Kappa,
H, Ph1BayesianLASSO.model$Gamma, Ph1BayesianLASSO.model$Tau,
Y2.tr0, X1, H1)
Y2.hat.sim <- Y2.tr.sim$fit
Y2.tr.sim <- Y2.tr.sim$Y.tr
Y.hat <- rep(NA, TT2)
if (Y.hat.method == "median") {
for (i in 1:TT2) {
Y.hat[i] <- median(Y2.hat.sim[i, ])
}
sigma2hat <- median(Ph1BayesianLASSO.model$sigma2)
} else if (Y.hat.method == "mean") {
Y.hat <- rowMeans(Y2.hat.sim)
sigma2hat <- mean(Ph1BayesianLASSO.model$sigma2)
}
sigmahat <- sqrt(sigma2hat)
lim.tr <- matrix(NA, nrow = TT2, ncol = 2)
sig.tr <- lim.tr[, 1]
ewma <- (Y - Y.hat[1:TT2]) / sigmahat
for (i in 2:TT2) {
ewma[i] <- lambda * ewma[i] + (1 - lambda) * ewma[i - 1]
}
if (plot == TRUE) {
if (cc.method == "adjusted alpha") {
adjalpha <- adjalpha.ph2(Y.hat, sigma2hat, Y2.tr.sim, ARL0, side, tol.chart)
for (i in 1:TT2) {
if (side == "two-sided") {
lim.tr[i, ] <- quantile(adjalpha$ewma[i, ], c(adjalpha$adjalpha / 2, 1 - adjalpha$adjalpha / 2))
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- quantile(adjalpha$ewma[i, ], c(1 - adjalpha$adjalpha))
} else if (side == "left-sided") {
lim.tr[i, 1] <- quantile(adjalpha$ewma[i, ], c(adjalpha$adjalpha))
lim.tr[i, 2] <- Inf
}
}
} else if (cc.method == "classic") {
cc <- cc.ph2(Y.hat, sigma2hat, Y2.tr.sim, ARL0, side, tol.chart)
for (i in 1:TT2) {
if (side == "two-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- cc$cc
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- cc$cc
} else if (side == "left-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- Inf
}
}
}
sig.tr <- (lim.tr[, 1] <= ewma) & (ewma <= lim.tr[, 2])
if (side == "two-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "right-sided") {
Ylim <- c(min(ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "left-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(ewma, na.rm = TRUE))
}
plot(c(1, TT2), Ylim, type = 'n',
main = "Phase II Chart for Transformed Moving Averages",
ylab = "EWMA",
xlab = "")
points(ewma, type = 'o')
points((1:TT2)[which(sig.tr == FALSE)], ewma[which(sig.tr == FALSE)], col = 'red', pch = 16)
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("EWMA" = ewma, "lim.tr" = lim.tr,
"sig.tr" = sig.tr, "Y.hat" = Y.hat)
out
}
chart2 <- Ph2BayesianLASSO.EWMA(Y2, chart1$model, lambda = 0.1, H = H2sim, X = X2sim,
Y1 = Y1[(q + w):TT1], X1 = X1[(q + w):TT1, ], H1 = H1[(q + w):TT1, ],
log = TRUE, const = 1, sta = TRUE, meanY = chart1$model$meanY, sdY = chart1$model$sdY,
Y.hat.method = "mean",
ARL0 = 360, side = "right-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = FALSE)
chart2
bb1$RMSE.tr
bb1$RMSE.ma
median(aa$RMSE.tr, bb$RMSE.tr)
median(aa$RMSE.tr)
median(bb$RMSE.tr)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(12345)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 200
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
library(BayesianLASSOMonitoring)
set.seed(12345)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 200
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
aa <- RMSE.ph1(chart1$model)
aa1 <- RMSE.ph2(Y2, chart1$model, X2, H2)
aa
aa
aa1 <- RMSE.ph2(Y2, chart1$model, X2, H2)
debug(RMSE.ph2)
aa1 <- RMSE.ph2(Y2, chart1$model, X2, H2)
tmpmuq
aa1 <- RMSE.ph2(Y2, chart1$model, X2, H2)
Y.tr
y.tr
Y.tr
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(12345)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 200
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
chart1 <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "median", side = "right-sided", FAP0 = 0.3,
log = TRUE, sta = TRUE, plot = FALSE)
aa <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model)
aa1 <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, X2, H2)
aa
aa1
aa$RMSE.ma
aa1$RMSE.ma
length(Y2)
TT1 <- 183
TT2 <- 365
w <- c(7, 14)
q <- 5
pars <- expand.grid(TT1, TT2, w, q)
pars
set.seed(12345)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- 183
TT2 <- 365
w <- c(7, 14)
q <- 5
pars <- expand.grid(TT1, TT2, w, q, 1:nnsim)
pars
nnsim <- 10
TT1 <- 183
TT2 <- 365
w <- c(7, 14)
q <- 5
pars <- expand.grid(TT1, TT2, w, q, 1:nnsim)
pars
chart1$lim.tr
nnsim <- 10
TT1 <- 183
TT2 <- 365
w <- c(7, 14)
q <- 5
delta <- 0.25
tt <- 0.5
Y.hat.method <- "median"
side <- "right-sided"
FAP0 <- 0.3
log <- TRUE
sta <- TRUE
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
TT1
TT2
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
alpha
lambda
pi
TT1
TT2
w
w <- 7
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
chart1 <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, const = 1, nsim.chart = 10000,
Y.hat.method = Y.hat.method, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE)
aa <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model)
chart1$model
debug(BayesianLASSOMonitoring::RMSE.ph1)
aa <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model)
debug(BayesianLASSOMonitoring::RMSE.ph1)
aa <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model)
X
Ph1BayesianLASSO.model$Beta
j
remove.packages("BayesianLASSOMonitoring")
