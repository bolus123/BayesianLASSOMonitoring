out5 <- getChart(Y1, w, H1, Y0, "MonoLASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out6 <- getChart(Y1, w, H1, Y0, "MonoALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out <- c(out1, out2, out3, out4, out5, out6)
YY <- c(Y0, Y1)
YY1 <- movaver(YY, w)
nn <- length(YY1)
YY1 <- YY1[(nn - TT1 + 1):nn]
YY1.tr <- trans(YY1, log, 1, sta)
tmp <- try(forecast::auto.arima(YY1.tr$Y), silent = TRUE)
RMSE.ph1.arima <- NA
RMSE.ph2.arima <- NA
if (class(tmp)[1] != "try-error") {
ph1 <- BayesianLASSOMonitoring::backtrans(tmp$fitted, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- mean((YY1 - ph1)^2)
ph2 <- BayesianLASSOMonitoring::backtrans(predict(tmp, n.ahead = length(Y2))$pred, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph2[which(ph2 < 0)] <- 0
YY <- c(Y1, Y2)
nn <- length(YY)
TT <- length(Y2)
q <- dim(chart1$mode$Phi)[1]
Y2.ma <- movaver(YY, chart1$model$w)[(nn - TT + 1):nn]
RMSE.ph2.arima <- mean((Y2.ma - ph2) ^ 2)
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
#tmpaddr <- paste('C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim', X, ".Rdat", sep = "")
#save(out, file = tmpaddr)
out
}
library(parallel)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 1
TT1 <- c(183)
TT2 <- 365
#w <- c(1, 7, 14, 28)
w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
tt <- dim(pars)[1]
#cl <- makeCluster(ceiling(detectCores() * 0.875), outfile = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim.log")
cl <- makeCluster(ceiling(detectCores() * 0.875))
clusterEvalQ(cl, library(BayesianLASSOMonitoring))
clusterEvalQ(cl, library(forecast))
clusterExport(cl, c("simulation.wrap", "getChart"))
out <- parLapplyLB(cl, 1:tt, simulation.wrap, pars = pars, alpha = alpha, lambda = lambda, pi = pi, seed = seed)
out
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none"),
silent = TRUE)
out <- rep(NA, 14)
if (class(chart1)[1] != "try-error") {
pvalue <- chart1$adj.pvalue
pvalue <- cbind(pvalue,
p.adjust(pvalue, "bonferroni"), p.adjust(pvalue, "holm"), p.adjust(pvalue, "BH"))
#tmpadjpvalue <- BayesianLASSOMonitoring::Ph1MultipleTesting(chart1$model,
#                                                            sign.method = "trinomial", adj.method = "none", side = side)
#pvalue <- cbind(pvalue, tmpadjpvalue,
#                p.adjust(tmpadjpvalue, "bonferroni"), p.adjust(tmpadjpvalue, "holm"), p.adjust(tmpadjpvalue, "BH"))
sig.tr <- pvalue < FAP0
sig <- colSums(sig.tr == TRUE) > 0
#lenoverall <- which(chart1$sig.tr == TRUE)[which.min(abs(which(chart1$sig.tr == TRUE) -
#                                                            (ceiling(TT1 * tt) + w - 1)))] - (ceiling(TT1 * tt) + w - 1)
#
#if (length(lenoverall) == 0) {
#  lenoverall <- NA
#}
#
#lenafter <- min(which(chart1$sig.tr == TRUE)[(which(chart1$sig.tr == TRUE) -
#                                                (ceiling(TT1 * tt) + w - 1)) >= 0] - (ceiling(TT1 * tt) + w - 1))
#
#if (length(lenafter) == 0) {
#  lenafter <- NA
#}
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr)
RMSE.ph1.ma <- median(tmp$RMSE.ma)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, NULL, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr)
RMSE.ph2.ma <- median(tmp$RMSE.ma)
out <- c(sig,
#lenoverall, lenafter,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
out
}
simulation.wrap <- function(X, pars, alpha, lambda, pi, seed = 12345) {
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
#X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
#X1 <- X[1:TT1, ]
#X2 <- X[(TT1 + 1):(TT1 + TT2), ]
#X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out2 <- getChart(Y1, w, H1, Y0, "regression",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out3 <- getChart(Y1, w, H1, Y0, "LASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out4 <- getChart(Y1, w, H1, Y0, "ALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out5 <- getChart(Y1, w, H1, Y0, "MonoLASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out6 <- getChart(Y1, w, H1, Y0, "MonoALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out <- c(out1, out2, out3, out4, out5, out6)
YY <- c(Y0, Y1)
YY1 <- movaver(YY, w)
nn <- length(YY1)
YY1 <- YY1[(nn - TT1 + 1):nn]
YY1.tr <- trans(YY1, log, 1, sta)
tmp <- try(forecast::auto.arima(YY1.tr$Y), silent = TRUE)
RMSE.ph1.arima <- NA
RMSE.ph2.arima <- NA
if (class(tmp)[1] != "try-error") {
ph1 <- BayesianLASSOMonitoring::backtrans(tmp$fitted, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- mean((YY1 - ph1)^2)
ph2 <- BayesianLASSOMonitoring::backtrans(predict(tmp, n.ahead = length(Y2))$pred, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph2[which(ph2 < 0)] <- 0
YY <- c(Y1, Y2)
nn <- length(YY)
TT <- length(Y2)
q <- dim(chart1$mode$Phi)[1]
Y2.ma <- movaver(YY, w)[(nn - TT + 1):nn]
RMSE.ph2.arima <- mean((Y2.ma - ph2) ^ 2)
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
#tmpaddr <- paste('C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim', X, ".Rdat", sep = "")
#save(out, file = tmpaddr)
out
}
library(parallel)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 1
TT1 <- c(183)
TT2 <- 365
#w <- c(1, 7, 14, 28)
w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
tt <- dim(pars)[1]
#cl <- makeCluster(ceiling(detectCores() * 0.875), outfile = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim.log")
cl <- makeCluster(ceiling(detectCores() * 0.875))
clusterEvalQ(cl, library(BayesianLASSOMonitoring))
clusterEvalQ(cl, library(forecast))
clusterExport(cl, c("simulation.wrap", "getChart"))
out <- parLapplyLB(cl, 1:tt, simulation.wrap, pars = pars, alpha = alpha, lambda = lambda, pi = pi, seed = seed)
chart1
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none"),
silent = TRUE)
out <- rep(NA, 14)
if (class(chart1)[1] != "try-error") {
pvalue <- chart1$adj.pvalue
pvalue <- cbind(pvalue,
p.adjust(pvalue, "bonferroni"), p.adjust(pvalue, "holm"), p.adjust(pvalue, "BH"))
#tmpadjpvalue <- BayesianLASSOMonitoring::Ph1MultipleTesting(chart1$model,
#                                                            sign.method = "trinomial", adj.method = "none", side = side)
#pvalue <- cbind(pvalue, tmpadjpvalue,
#                p.adjust(tmpadjpvalue, "bonferroni"), p.adjust(tmpadjpvalue, "holm"), p.adjust(tmpadjpvalue, "BH"))
sig.tr <- pvalue < FAP0
sig <- colSums(sig.tr == TRUE) > 0
#lenoverall <- which(chart1$sig.tr == TRUE)[which.min(abs(which(chart1$sig.tr == TRUE) -
#                                                            (ceiling(TT1 * tt) + w - 1)))] - (ceiling(TT1 * tt) + w - 1)
#
#if (length(lenoverall) == 0) {
#  lenoverall <- NA
#}
#
#lenafter <- min(which(chart1$sig.tr == TRUE)[(which(chart1$sig.tr == TRUE) -
#                                                (ceiling(TT1 * tt) + w - 1)) >= 0] - (ceiling(TT1 * tt) + w - 1))
#
#if (length(lenafter) == 0) {
#  lenafter <- NA
#}
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr)
RMSE.ph1.ma <- median(tmp$RMSE.ma)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, NULL, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr)
RMSE.ph2.ma <- median(tmp$RMSE.ma)
out <- c(sig,
#lenoverall, lenafter,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
out
}
simulation.wrap <- function(X, pars, alpha, lambda, pi, seed = 12345) {
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
#X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
#X1 <- X[1:TT1, ]
#X2 <- X[(TT1 + 1):(TT1 + TT2), ]
#X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out2 <- getChart(Y1, w, H1, Y0, "regression",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out3 <- getChart(Y1, w, H1, Y0, "LASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out4 <- getChart(Y1, w, H1, Y0, "ALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out5 <- getChart(Y1, w, H1, Y0, "MonoLASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out6 <- getChart(Y1, w, H1, Y0, "MonoALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out <- c(out1, out2, out3, out4, out5, out6)
YY <- c(Y0, Y1)
YY1 <- movaver(YY, w)
nn <- length(YY1)
YY1 <- YY1[(nn - TT1 + 1):nn]
YY1.tr <- trans(YY1, log, 1, sta)
tmp <- try(forecast::auto.arima(YY1.tr$Y), silent = TRUE)
RMSE.ph1.arima <- NA
RMSE.ph2.arima <- NA
if (class(tmp)[1] != "try-error") {
ph1 <- BayesianLASSOMonitoring::backtrans(tmp$fitted, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- mean((YY1 - ph1)^2)
ph2 <- BayesianLASSOMonitoring::backtrans(predict(tmp, n.ahead = length(Y2))$pred, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph2[which(ph2 < 0)] <- 0
YY <- c(Y1, Y2)
nn <- length(YY)
TT <- length(Y2)
Y2.ma <- movaver(YY, w)[(nn - TT + 1):nn]
RMSE.ph2.arima <- mean((Y2.ma - ph2) ^ 2)
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
#tmpaddr <- paste('C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim', X, ".Rdat", sep = "")
#save(out, file = tmpaddr)
out
}
library(parallel)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 1
TT1 <- c(183)
TT2 <- 365
#w <- c(1, 7, 14, 28)
w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
tt <- dim(pars)[1]
#cl <- makeCluster(ceiling(detectCores() * 0.875), outfile = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim.log")
cl <- makeCluster(ceiling(detectCores() * 0.875))
clusterEvalQ(cl, library(BayesianLASSOMonitoring))
clusterEvalQ(cl, library(forecast))
clusterExport(cl, c("simulation.wrap", "getChart"))
out <- parLapplyLB(cl, 1:tt, simulation.wrap, pars = pars, alpha = alpha, lambda = lambda, pi = pi, seed = seed)
#save(out, file = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/out.Rdat")
closeAllConnections()
warnings()
out
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none"),
silent = TRUE)
out <- rep(NA, 14)
if (class(chart1)[1] != "try-error") {
pvalue <- chart1$adj.pvalue
pvalue <- cbind(pvalue,
p.adjust(pvalue, "bonferroni"), p.adjust(pvalue, "holm"), p.adjust(pvalue, "BH"))
tmpadjpvalue <- BayesianLASSOMonitoring::Ph1MultipleTesting(chart1$model,
sign.method = "trinomial", adj.method = "none", side = side)
pvalue <- cbind(pvalue, tmpadjpvalue,
p.adjust(tmpadjpvalue, "bonferroni"), p.adjust(tmpadjpvalue, "holm"), p.adjust(tmpadjpvalue, "BH"))
sig.tr <- pvalue < FAP0
sig <- colSums(sig.tr == TRUE) > 0
#lenoverall <- which(chart1$sig.tr == TRUE)[which.min(abs(which(chart1$sig.tr == TRUE) -
#                                                            (ceiling(TT1 * tt) + w - 1)))] - (ceiling(TT1 * tt) + w - 1)
#
#if (length(lenoverall) == 0) {
#  lenoverall <- NA
#}
#
#lenafter <- min(which(chart1$sig.tr == TRUE)[(which(chart1$sig.tr == TRUE) -
#                                                (ceiling(TT1 * tt) + w - 1)) >= 0] - (ceiling(TT1 * tt) + w - 1))
#
#if (length(lenafter) == 0) {
#  lenafter <- NA
#}
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr)
RMSE.ph1.ma <- median(tmp$RMSE.ma)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, NULL, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr)
RMSE.ph2.ma <- median(tmp$RMSE.ma)
out <- c(sig,
#lenoverall, lenafter,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
out
}
simulation.wrap <- function(X, pars, alpha, lambda, pi, seed = 12345) {
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
#X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
#X1 <- X[1:TT1, ]
#X2 <- X[(TT1 + 1):(TT1 + TT2), ]
#X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out2 <- getChart(Y1, w, H1, Y0, "regression",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out3 <- getChart(Y1, w, H1, Y0, "LASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out4 <- getChart(Y1, w, H1, Y0, "ALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out5 <- getChart(Y1, w, H1, Y0, "MonoLASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out6 <- getChart(Y1, w, H1, Y0, "MonoALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out <- c(out1, out2, out3, out4, out5, out6)
YY <- c(Y0, Y1)
YY1 <- movaver(YY, w)
nn <- length(YY1)
YY1 <- YY1[(nn - TT1 + 1):nn]
YY1.tr <- trans(YY1, log, 1, sta)
tmp <- try(forecast::auto.arima(YY1.tr$Y), silent = TRUE)
RMSE.ph1.arima <- NA
RMSE.ph2.arima <- NA
if (class(tmp)[1] != "try-error") {
ph1 <- BayesianLASSOMonitoring::backtrans(tmp$fitted, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- mean((YY1 - ph1)^2)
ph2 <- BayesianLASSOMonitoring::backtrans(predict(tmp, n.ahead = length(Y2))$pred, log, 1,
sta,
YY1.tr$meanY, YY1.tr$sdY)
ph2[which(ph2 < 0)] <- 0
YY <- c(Y1, Y2)
nn <- length(YY)
TT <- length(Y2)
Y2.ma <- movaver(YY, w)[(nn - TT + 1):nn]
RMSE.ph2.arima <- mean((Y2.ma - ph2) ^ 2)
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
#tmpaddr <- paste('C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim', X, ".Rdat", sep = "")
#save(out, file = tmpaddr)
out
}
library(parallel)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 1
TT1 <- c(183)
TT2 <- 365
#w <- c(1, 7, 14, 28)
w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
tt <- dim(pars)[1]
#cl <- makeCluster(ceiling(detectCores() * 0.875), outfile = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/sim.log")
cl <- makeCluster(ceiling(detectCores() * 0.875))
clusterEvalQ(cl, library(BayesianLASSOMonitoring))
clusterEvalQ(cl, library(forecast))
clusterExport(cl, c("simulation.wrap", "getChart"))
out <- parLapplyLB(cl, 1:tt, simulation.wrap, pars = pars, alpha = alpha, lambda = lambda, pi = pi, seed = seed)
#save(out, file = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/New folder/tmp/out.Rdat")
closeAllConnections()
out
w
?
a
?simulate
?forecast
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
