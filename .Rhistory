m1$Phi
m1$Gamma
m1$Tau
m1$TauGrp
rep(m1$Tau0)
rep(m1$Tau0, T)
dim(rep(m1$Tau0, T))
matrix(rep(m1$Tau0, T), nrow = T, byrow = TRUE)
aa <- matrix(rep(m1$Tau0, T), nrow = T, byrow = TRUE)
aa
aa[1, ]
aa[2, ]
aa[, 1]
aa[, 3]
aa <- m1$Tau * m1$TauGrp * matrix(rep(m1$Tau0, T), nrow = T, byrow = TRUE) * m1$Gamma
dim(m1$Tau)
dim(m1$TauGrp)
aa <- m1$Tau * m1$TauGrp * matrix(rep(m1$Tau0, T - 5), nrow = T - 5, byrow = TRUE) * m1$Gamma
aa
getH0(aa)
#' get a true proportion of H0
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
#' @param method get p values with or without kernel smoothing.
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' getH0(result$Tau * result$Gamma)
getH0 <- function(TauGamma, tail = "2-sided", FDR.method = "meinshausen", pvalue.method = "raw") {
pvalue <- getPvalue(TauGamma, tail, pvalue.method)
get.pi0(pvalue, estim.method = FDR.method)
}
getH0(aa)
#' get the P value for RFLSM with kernel smoothing
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueKSRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
tmpkde <- density(tmp[i, ])
rtmpdens <- spatstat.explore::CDF(tmpkde)
tmpp <- rtmpdens(0)
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - tmpp, tmpp)
} else if (tail == "left-sided") {
pvalue[i] <- tmpp
} else if (tail == "right-sided") {
pvalue[i] <- 1 - tmpp
}
}
return(pvalue)
}
#' get the P value for RFLSM
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - mean(tmp[i, ] <= 0), mean(tmp[i, ] <= 0))
} else if (tail == "left-sided") {
pvalue[i] <- mean(tmp[i, ] <= 0)
} else if (tail == "right-sided") {
pvalue[i] <- 1 - mean(tmp[i, ] <= 0)
}
}
return(pvalue)
}
#' get a vector of p values
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
#' @param method get p values with or without kernel smoothing.
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' getPvalue(result$Tau * result$Gamma)
getPvalue <- function(TauGamma, tail = "2-sided", method = "raw") {
if (method == "raw") {
pvalue <- getPvalueRFLSM(TauGamma, tail)
} else if (method == "ks") {
pvalue <- getPvalueKSRFLSM(TauGamma, tail)
}
pvalue
}
getH0(aa)
library(FDRestimation)
library(FDRestimation)
install.packages("FDRestimation")
library(FDRestimation)
getH0(aa)
H <- getHMatMT(T, 5)
Group <- matrix(rep(1:5, each = 80, length.out = dim(H)[2]), ncol = 1)
m1 <- GibbsRFLSMGrp(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, 1, 1, 1, 1, 1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10, H, Group)
m12 <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10)
aa <- m1$Tau * m1$TauGrp * matrix(rep(m1$Tau0, T - 5), nrow = T - 5, byrow = TRUE) * m1$Gamma
getH0(aa)
getH0(m12$Tau * m12$Gamma)
m12$Tau * m12$Gamma
getH0(m12$Tau * m12$Gamma)
aa
m12$Tau * m12$Gamma
m12$Tau
dim(m12$Tau * m12$Gamma)
dim(m12$Tau * m12$Gamma)
dim( m12$Gamma)
dim( m1$Gamma)
Rcpp::sourceCpp("src/BayesianLassoMonitoring.cpp")
m1 <- GibbsRFLSMGrp(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, 1, 1, 1, 1, 1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10, H, Group)
m12 <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10)
m12$Tau
BayesianLassoMonitoring::GibbsRFLSM
Rcpp::sourceCpp("src/BayesianLassoMonitoring.cpp")
m12 <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10)
m12
m12$Tau
GibbsRFLSM
m12 <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10, H)
getH0(m12$Tau * m12$Gamma)
T <- 365
Y <- arima.sim(list(ar = 0.5), n = T)
Y[183:365] <- Y[183:365] + 10
m0 <- GibbsRFLSMGrp(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, 0, 1, 1, 1, 1, "MT", Inf, 0, 1000, 1, 1000, 1e-10)
H <- getHMatMT(T, 5)
Group <- matrix(rep(1:5, each = 80, length.out = dim(H)[2]), ncol = 1)
m1 <- GibbsRFLSMGrp(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, 1, 1, 1, 1, 1,
"MT", Inf, 0, 1000, 1, 1000, 1e-10, H, Group)
aa <- m1$Tau * m1$TauGrp * matrix(rep(m1$Tau0, T - 5), nrow = T - 5, byrow = TRUE) * m1$Tau * m1$Gamma
getH0(aa)
m1$Gamma
aa
dim(aa)
aa[178]
aa[178, ]
m1$Tau0
mean(m1$Tau0)
aa[177, ]
aa[178, ]
aa[179, ]
rnorm(10, 125, 10)
rnorm(10, 125, 5)
rnorm(5, 125, 10)
rnorm(5, 125, 10)
rnorm(5, 125, 10)
devtools::install_github("bolus123/BayesianLassoMonitoring")
?mm Hg
?BayesianLassoMonitoring
?BayesianLassoMonitoring::GibbsRFLSM
set.seed(12345)
H <- BayesianLassoMonitoring::getHMatMT(183, 3)
Y0 <- arima.sim(list(ar = 0.5), 183)
m0 <- BayesianLassoMonitoring::GibbsRFLSM(Y0, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0
1000, 1, 1000, 1e-6, H)
set.seed(12345)
H <- BayesianLassoMonitoring::getHMatMT(183, 3)
Y0 <- arima.sim(list(ar = 0.5), 183)
m0 <- BayesianLassoMonitoring::GibbsRFLSM(Y0, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
1000, 1, 1000, 1e-6, H)
Y1 <- Y0
Y1[92:183] <- Y1[92:183] + 5
m1 <- BayesianLassoMonitoring::GibbsRFLSM(Y1, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
1000, 1, 1000, 1e-6, H)
pval01 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma)
pval02 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma, method = "ks")
pval11 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma)
pval12 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma, method = "ks")
pval01
pval02
pval11
pval12
install.packages('ks')
getPvalueKSRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
tmpkde <- ks::kde(tmp[i, ])
tmpp <- ks::pkde(0, tmpkde)
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - tmpp, tmpp)
} else if (tail == "left-sided") {
pvalue[i] <- tmpp
} else if (tail == "right-sided") {
pvalue[i] <- 1 - tmpp
}
}
return(pvalue)
}
pval01 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma)
pval02 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma, method = "ks")
pval02
pval02 <- getPvalue(m0$Tau * m0$Gamma, method = "ks")
getPvalueKSRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
tmpkde <- ks::kde(tmp[i, ])
tmpp <- ks::pkde(0, tmpkde)
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - tmpp, tmpp)
} else if (tail == "left-sided") {
pvalue[i] <- tmpp
} else if (tail == "right-sided") {
pvalue[i] <- 1 - tmpp
}
}
return(pvalue)
}
#' get the P value for RFLSM with kernel smoothing
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueKSRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
tmpkde <- ks::kde(tmp[i, ])
tmpp <- ks::pkde(0, tmpkde)
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - tmpp, tmpp)
} else if (tail == "left-sided") {
pvalue[i] <- tmpp
} else if (tail == "right-sided") {
pvalue[i] <- 1 - tmpp
}
}
return(pvalue)
}
#' get the P value for RFLSM
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - mean(tmp[i, ] <= 0), mean(tmp[i, ] <= 0))
} else if (tail == "left-sided") {
pvalue[i] <- mean(tmp[i, ] <= 0)
} else if (tail == "right-sided") {
pvalue[i] <- 1 - mean(tmp[i, ] <= 0)
}
}
return(pvalue)
}
#' get a vector of p values
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
#' @param method get p values with or without kernel smoothing.
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' getPvalue(result$Tau * result$Gamma)
getPvalue <- function(TauGamma, tail = "2-sided", method = "raw") {
if (method == "raw") {
pvalue <- getPvalueRFLSM(TauGamma, tail)
} else if (method == "ks") {
pvalue <- getPvalueKSRFLSM(TauGamma, tail)
}
pvalue
}
pval02 <- getPvalue(m0$Tau * m0$Gamma, method = "ks")
debug(getPvalueKSRFLSM)
pval02 <- getPvalue(m0$Tau * m0$Gamma, method = "ks")
debug(getPvalueKSRFLSM)
pval02 <- getPvalue(m0$Tau * m0$Gamma, method = "ks")
tmp
dim(tmp)
tmp[1, ]
ks::kde(tmp[1, ])
pval01 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma)
pval02 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma, method = "ks")
pval02
install.packages("fdrtool")
fdrtool
fdr
fdr
fdrtool::fdrtool(pval01, "pvalues")
fdrtool::fdrtool(pval01, "pvalue")
fdrtool::fdrtool(pval01, "pvalue")
fdrtool::fdrtool(pval02, "pvalue")
pval11 <- BayesianLassoMonitoring::getPvalue(m1$Tau * m1$Gamma)
fdrtool::fdrtool(pval11, "pvalue")
pval11
pval12 <- BayesianLassoMonitoring::getPvalue(m1$Tau * m1$Gamma, method = "ks")
pval12
fdrtool::fdrtool(pval11, "pvalue")
?pval11
?pval11
?fdrtool::fdrtool
fdrtool::pval.estimate.eta0(pval11)
?pval.estimate.eta0
fdrtool::pval.estimate.eta0(pval11, method = "bootstrap")
aa <- m1$Tau * m1$Gamma
dim(H)
aa[89, ]
hist(aa[89, ])
aa[89, ] < 0
mean(aa[89, ] < 0)
1 - mean(aa[89, ] < 0)
pval11
mean(aa[89, ] < 0)
mean(aa[89, ] > 0)
#' get the P value for RFLSM with kernel smoothing
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueKSRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
tmpkde <- density(tmp[i, ])
rtmpdens <- spatstat.explore::CDF(tmpkde)
tmpp <- rtmpdens(0)
if (tail == "2-sided") {
pvalue[i] <- 2 * min(1 - tmpp, tmpp)
} else if (tail == "left-sided") {
pvalue[i] <- tmpp
} else if (tail == "right-sided") {
pvalue[i] <- 1 - tmpp
}
}
return(pvalue)
}
#' get the P value for RFLSM
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
getPvalueRFLSM <- function(TauGamma, tail = "2-sided") {
tmp <- TauGamma
nn <- dim(tmp)[1]
pvalue <- rep(0, nn)
for (i in 1:nn) {
if (tail == "2-sided") {
pvalue[i] <- mean(tmp[i, ] != 0)
} else if (tail == "left-sided") {
pvalue[i] <- mean(tmp[i, ] < 0)
} else if (tail == "right-sided") {
pvalue[i] <- mean(tmp[i, ] > 0)
}
}
return(pvalue)
}
#' get a vector of p values
#'
#' @param TauGamma is the distributions of shifts.
#' @param tail is type of the test.
#' @param method get p values with or without kernel smoothing.
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' getPvalue(result$Tau * result$Gamma)
getPvalue <- function(TauGamma, tail = "2-sided", method = "raw") {
if (method == "raw") {
pvalue <- getPvalueRFLSM(TauGamma, tail)
} else if (method == "ks") {
pvalue <- getPvalueKSRFLSM(TauGamma, tail)
}
pvalue
}
remove.packages("BayesianLassoMonitoring")
devtools::install_github("bolus123/BayesianLassoMonitoring")
devtools::install_github("bolus123/BayesianLassoMonitoring")
.seed(12345)
set.seed(12345)
H <- BayesianLassoMonitoring::getHMatMT(183, 3)
Y0 <- arima.sim(list(ar = 0.5), 183)
m0 <- BayesianLassoMonitoring::GibbsRFLSM(Y0, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
3000, 1, 1000, 1e-6, H)
pval01 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma)
fdrtool::fdrtool(pval01, "pvalue")
pval01
pval02 <- BayesianLassoMonitoring::getPvalue(m0$Tau * m0$Gamma, method = "ks")
fdrtool::fdrtool(pval02, "pvalue")
pval01
fdrtool::fdrtool(pval01, "pvalue")
Y1 <- Y0
Y1[92:183] <- Y1[92:183] + 5
m1 <- BayesianLassoMonitoring::GibbsRFLSM(Y1, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
3000, 1, 1000, 1e-6, H)
pval11 <- BayesianLassoMonitoring::getPvalue(m1$Tau * m1$Gamma)
fdrtool::fdrtool(pval11, "pvalue")
m0
pval01
rowMeans(m0$Tau == 0)
rowMeans(m1$Tau == 0)
fdrtool::fdrtool(rowMeans(m0$Tau == 0), "pvalue")
fdrtool::fdrtool(rowMeans(m1$Tau == 0), "pvalue")
?fdrtool::fdrtool
FDRestimation::p.fdr(rowMeans(m1$Tau == 0))
?FDRestimation::p.fdr
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), estim.method = "last.hist")
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), estim.method = "meinshausen")
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), estim.method = "storey")
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), estim.method = "storey", threshold = 0.2)
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), estim.method = "last.hist", threshold = 0.2)
?fdrtool::fdrtool
fdrtool::fdrtool(rowMeans(m1$Tau == 0), "pvalue")
m1 <- BayesianLassoMonitoring::GibbsRFLSM(Y1, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
5000, 1, 1000, 1e-6, H)
fdrtool::fdrtool(rowMeans(m1$Tau == 0), "pvalue")
FDRestimation::p.fdr(rowMeans(m1$Tau == 0))
FDRestimation::p.fdr(rowMeans(m1$Tau == 0), threshold = 0.2)
colSums(m1$Tau)
colSums(m1$Tau) == 0
sum(colSums(m1$Tau) == 0)
sum(colSums(m0$Tau) == 0)
mean(colSums(m0$Tau) == 0)
mean(colSums(m0$Tau) == 0) /  mean(colSums(m0$Tau) == 1)
mean(colSums(m1$Tau) == 0) /  mean(colSums(m1$Tau) == 1)
BayesianLassoMonitoring::ll(Y, m0$Phi, m0$Mu, m0$sigma2)
BayesianLassoMonitoring::ll(Y0, m0$Phi, m0$Mu, m0$sigma2)
aa <- BayesianLassoMonitoring::ll(Y0, m0$Phi, m0$Mu, m0$sigma2)
aa
aa
m0 <- BayesianLassoMonitoring::GibbsRFLSM(Y1, 3, diag(nrow = 3), 0.1, 0.1,
0.1, 0.1, 1, 1, 0.1, "MonoALASSO", Inf, 0,
5000, 1, 1000, 1e-6)
m0
aa <- BayesianLassoMonitoring::ll(Y1, m0$Phi, m0$Mu, m0$sigma2)
aa
aa
dim(aaa)
dim(aa)
aa[, 1]
bb <- BayesianLassoMonitoring::ll(Y1, m1$Phi, m1$Mu, m1$sigma2)
bb
bb[, 1]
bb[, 2]
bb[, 3]
aa[, 3]
sum(aa[, 3]) / sum(bb[, 3])
sum(aa[, 3]) / sum(bb[, 4])
sum(aa[, 3]) / sum(bb[, 5])
sum(aa[, 3]) - sum(bb[, 5])
exp(a[, 3])
exp(aa[, 3])
exp(aa[, 3]) / exp(bb[, 3])
log(exp(aa[, 3]) / exp(bb[, 3]))
sum(log(exp(aa[, 3]) / exp(bb[, 3])))
exp(sum(log(exp(aa[, 3]) / exp(bb[, 3]))))
exp(sum(log(exp(aa[, 3]) / exp(bb[, 7]))))
exp(sum(log(exp(aa[, 3]) / exp(bb[, 10]))))
exp(sum(log(exp(aa[, 3]) / exp(bb[, 90]))))
aa[, 3]
sum(aa[, 3])
sum(aa[, 3]) - sum(bb[, 3])
exp(sum(aa[, 3]) - sum(bb[, 3]))
?log
log10(exp(sum(aa[, 3]) - sum(bb[, 3])))
mean(colSums(m1$Tau) == 0) /  mean(colSums(m1$Tau) == 1)
mean(colSums(m1$Tau) == 0) /  mean(colSums(m1$Tau) == 1)
colSums(m1$Tau)
mean(colSums(m1$Tau) == 0) /  mean(colSums(m1$Tau) > 1)
mean(colSums(m1$Tau) > 1)
mean(colSums(m1$Tau) == 0) /  mean(colSums(m1$Tau) >= 1)
mean(colSums(m1$Tau) == 0)
mean(colSums(m1$Tau) > 1)
mean(colSums(m1$Tau) >= 1)
