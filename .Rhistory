points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("model" = model, "cc" = cc$cc, "lim.tr" = lim.tr,
"sig.tr" = sig.tr)
out
}
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param Y0 is the initial Y
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param standardized is the flag triggering the standardization for the time series
#' @param logcc is the log transformation with continuity correction
#' @param FAP0 is the given false alarm probability
#' @param estimation.PPP is the estimation for Mu0, Phi and sigma2
#' @param nsim.PPP is the number of draws for PPP
#'
#'
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- Ph1BayesianLASSO(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
Ph2BayesianLASSO.EWMA <- function(Y, Ph1BayesianLASSO.model, lambda = 0.05, w = 28, H = NULL, X = NULL,
Y1 = rep(0, dim(Ph1BayesianLASSO.model$Phi)[1] + w), X1 = NULL, H1 = NULL,
log = TRUE, const = 1, sta = TRUE,
Y.hat.method = "median",
ARL0 = 360, side = "two-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
TT2 <- length(Y)
q <- dim(Ph1BayesianLASSO.model$Phi)[1]
Y2 <- c(Y1, Y)
TT <- length(Y2)
Y2.ma <- movaver(Y2, w)[(TT - TT2 - q + 1):TT]
Y2.tr <- trans(Y2.ma, log, const, sta)
Y2.tr0 <- Y2.tr[1:q]
Y2.tr1 <- Y2.tr[-c(1:q)]
Y2.tr.sim <- GibbsRFLSM.sim.ph2(max.length, nsim.chart,
Ph1BayesianLASSO.model$Phi, Ph1BayesianLASSO.model$muq, Ph1BayesianLASSO.model$sigma2,
X, Ph1BayesianLASSO.model$Beta, Ph1BayesianLASSO.model$Kappa,
H, Ph1BayesianLASSO.model$Gamma, Ph1BayesianLASSO.model$Tau,
Y2.tr0, X1, H1)$Y.tr
Y.hat <- rep(NA, TT2)
if (Y.hat.method == "median") {
for (i in 1:TT2) {
Y.hat[i] <- median(Y2.tr.sim[i, ])
}
sigma2hat <- median(Ph1BayesianLASSO.model$sigma2)
} else if (Y.hat.method == "mean") {
Y.hat <- rowMeans(Y2.tr.sim)
sigma2hat <- mean(Ph1BayesianLASSO.model$sigma2)
}
cc <- cc.ph2(Y.hat, sigma2hat, Y2.tr.sim, ARL0, side, tol.chart)
ewma <- (Y - Y.hat[1:TT2]) / sqrt(sigma2hat)
for (i in 2:TT2) {
ewma[i] <- lambda * (Y[i] - Y.hat[i]) / sqrt(sigma2hat) + (1 - lambda) * ewma[i - 1]
}
lim.tr <- matrix(NA, nrow = TT2, ncol = 2)
for (i in 1:TT2) {
if (side == "two-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- cc$cc
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- cc$cc
} else if (side == "left-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- Inf
}
}
sig.tr <- (lim.tr[, 1] <= ewma) & (ewma <= lim.tr[, 2])
if (plot == TRUE) {
if (side == "two-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "right-sided") {
Ylim <- c(min(ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "left-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(ewma, na.rm = TRUE))
}
plot(c(1, TT2), Ylim, type = 'n',
main = "Phase II Chart for Transformed Moving Averages",
ylab = "EWMA",
xlab = "")
points(ewma, type = 'o')
points((1:TT2)[which(sig.tr == FALSE)], ewma[which(sig.tr == FALSE)], col = 'red', pch = 16)
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("EWMA" = ewma, "cc" = cc$cc, "lim.tr" = lim.tr,
"sig.tr" = sig.tr)
out
}
log(10)
log(-1)
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param Y0 is the initial Y
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param standardized is the flag triggering the standardization for the time series
#' @param logcc is the log transformation with continuity correction
#' @param FAP0 is the given false alarm probability
#' @param estimation.PPP is the estimation for Mu0, Phi and sigma2
#' @param nsim.PPP is the number of draws for PPP
#'
#'
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- Ph1BayesianLASSO(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
Ph1BayesianLASSO <- function(Y, w = 28, H = NULL, X = NULL, Y0 = rep(mean(Y), w - 1), q = 5,
A = diag(nrow = q + ifelse(is.null(X), 0, dim(X)[2])),
a = 0.1, b = 0.1, alpha = 0.1, beta = 0.1,
theta1 = 1, theta2 = 1, xi2 = 0.1,
method = "MonoALASSO", bound0 = Inf, boundqplus1 = 0,
nsim = 1000, by = 1, burnin = 1000, tol = 1e-10,
log = TRUE, const = 1, sta = TRUE,
Y.hat.method = "median",
FAP0 = 0.3, side = "two-sided",
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
TT <- length(Y)
model <- GibbsRFLSM.count(Y, w, H, X, Y0, q,
A, a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin, tol,
log, const, sta)
Y.tr.sim <- GibbsRFLSM.sim.ph1(nsim.chart, model$Y.tr,
model$Phi, model$muq, model$sigma2,
X, model$Beta, model$Kappa,
NULL, NULL, NULL)$Y.tr
Y.hat <- rep(NA, TT - q)
if (Y.hat.method == "median") {
for (i in 1:(TT - q)) {
Y.hat[i] <- median(Y.tr.sim[i, ])
}
sigma2hat <- median(model$sigma2)
} else if (Y.hat.method == "mean") {
Y.hat <- rowMeans(Y.tr.sim)
sigma2hat <- mean(model$sigma2)
}
cc <- cc.ph1(Y.hat, sigma2hat, Y.tr.sim, FAP0, side, tol.chart)
lim.tr <- matrix(NA, nrow = TT, ncol = 2)
for (i in (q + 1):TT) {
if (side == "two-sided") {
lim.tr[i, 1] <- Y.hat[i - q] - cc$cc * sigma2hat
lim.tr[i, 2] <- Y.hat[i - q] + cc$cc * sigma2hat
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- Y.hat[i - q] + cc$cc * sigma2hat
} else if (side == "left-sided") {
lim.tr[i, 1] <- Y.hat[i - q] - cc$cc * sigma2hat
lim.tr[i, 2] <- Inf
}
}
sig.tr <- (lim.tr[, 1] <= model$Y.tr) & (model$Y.tr <= lim.tr[, 2])
if (plot == TRUE) {
if (side == "two-sided") {
Ylim <- c(min(lim.tr, model$Y.tr, na.rm = TRUE), max(lim.tr, model$Y.tr, na.rm = TRUE))
} else if (side == "right-sided") {
Ylim <- c(min(model$Y.tr, na.rm = TRUE), max(lim.tr, model$Y.tr, na.rm = TRUE))
} else if (side == "left-sided") {
Ylim <- c(min(lim.tr, model$Y.tr, na.rm = TRUE), max(model$Y.tr, na.rm = TRUE))
}
plot(c(1, TT), Ylim, type = 'n',
main = "Phase I Chart for Transformed Moving Averages",
ylab = "Transformed Moving Averages",
xlab = "")
points(model$Y.tr, type = 'o')
points((1:TT)[which(sig.tr == FALSE)], model$Y.tr[which(sig.tr == FALSE)], col = 'red', pch = 16)
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("model" = model, "cc" = cc$cc, "lim.tr" = lim.tr,
"sig.tr" = sig.tr)
out
}
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param Y0 is the initial Y
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param standardized is the flag triggering the standardization for the time series
#' @param logcc is the log transformation with continuity correction
#' @param FAP0 is the given false alarm probability
#' @param estimation.PPP is the estimation for Mu0, Phi and sigma2
#' @param nsim.PPP is the number of draws for PPP
#'
#'
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- Ph1BayesianLASSO(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
Ph2BayesianLASSO.EWMA <- function(Y, Ph1BayesianLASSO.model, lambda = 0.05, w = 28, H = NULL, X = NULL,
Y1 = rep(0, dim(Ph1BayesianLASSO.model$Phi)[1] + w), X1 = NULL, H1 = NULL,
log = TRUE, const = 1, sta = TRUE, meanY = 0, sdY = 1,
Y.hat.method = "median",
ARL0 = 360, side = "two-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
TT2 <- length(Y)
q <- dim(Ph1BayesianLASSO.model$Phi)[1]
Y2 <- c(Y1, Y)
TT <- length(Y2)
Y2.ma <- movaver(Y2, w)[(TT - TT2 - q + 1):TT]
if (log == TRUE) {
Y2.tr <- log(Y2.ma + const)
}
if (sta == TRUE) {
Y2.tr <- (Y2.tr - meanY) / sdY
}
Y2.tr0 <- Y2.tr[1:q]
Y2.tr1 <- Y2.tr[-c(1:q)]
Y2.tr.sim <- GibbsRFLSM.sim.ph2(max.length, nsim.chart,
Ph1BayesianLASSO.model$Phi, Ph1BayesianLASSO.model$muq, Ph1BayesianLASSO.model$sigma2,
X, Ph1BayesianLASSO.model$Beta, Ph1BayesianLASSO.model$Kappa,
H, Ph1BayesianLASSO.model$Gamma, Ph1BayesianLASSO.model$Tau,
Y2.tr0, X1, H1)$Y.tr
Y.hat <- rep(NA, TT2)
if (Y.hat.method == "median") {
for (i in 1:TT2) {
Y.hat[i] <- median(Y2.tr.sim[i, ])
}
sigma2hat <- median(Ph1BayesianLASSO.model$sigma2)
} else if (Y.hat.method == "mean") {
Y.hat <- rowMeans(Y2.tr.sim)
sigma2hat <- mean(Ph1BayesianLASSO.model$sigma2)
}
cc <- cc.ph2(Y.hat, sigma2hat, Y2.tr.sim, ARL0, side, tol.chart)
ewma <- (Y - Y.hat[1:TT2]) / sqrt(sigma2hat)
for (i in 2:TT2) {
ewma[i] <- lambda * (Y[i] - Y.hat[i]) / sqrt(sigma2hat) + (1 - lambda) * ewma[i - 1]
}
lim.tr <- matrix(NA, nrow = TT2, ncol = 2)
for (i in 1:TT2) {
if (side == "two-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- cc$cc
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.tr[i, 2] <- cc$cc
} else if (side == "left-sided") {
lim.tr[i, 1] <- - cc$cc
lim.tr[i, 2] <- Inf
}
}
sig.tr <- (lim.tr[, 1] <= ewma) & (ewma <= lim.tr[, 2])
if (plot == TRUE) {
if (side == "two-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "right-sided") {
Ylim <- c(min(ewma, na.rm = TRUE), max(lim.tr, ewma, na.rm = TRUE))
} else if (side == "left-sided") {
Ylim <- c(min(lim.tr, ewma, na.rm = TRUE), max(ewma, na.rm = TRUE))
}
plot(c(1, TT2), Ylim, type = 'n',
main = "Phase II Chart for Transformed Moving Averages",
ylab = "EWMA",
xlab = "")
points(ewma, type = 'o')
points((1:TT2)[which(sig.tr == FALSE)], ewma[which(sig.tr == FALSE)], col = 'red', pch = 16)
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("EWMA" = ewma, "cc" = cc$cc, "lim.tr" = lim.tr,
"sig.tr" = sig.tr)
out
}
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 3
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0
length(Y0)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 3
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
Y2
length(Y2)
length(Y1)
Y0
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 3
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = 100, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1]
X2 <- X[(TT1 + 1):(TT1 + TT2)]
X2sim <- X[(TT1 + 1):(TT1 + 5000)]
H1
dim(H1)
dim(X1)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 3
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = 100, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
dim(H1)
dim(X1)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 3
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = 100, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000)
result <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, side = "right-sided", FAP0 = 0.1)
result <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, side = "right-sided", FAP0 = 0.01)
result <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "mean", side = "right-sided", FAP0 = 0.01)
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "mean", side = "right-sided", FAP0 = 0.01)
debug(Ph2BayesianLASSO.EWMA)
chart2 <- Ph2BayesianLASSO.EWMA(Y2, chart1$model, lambda = 0.05, w = 28, H = H2sim, X = X2sim,
Y1 = Y1[(q + w):TT1], X1 = X1[(q + w):TT1, ], H1 = H1[(q + w):TT1, ],
log = TRUE, const = 1, sta = TRUE, meanY = chart1$model$meanY, sdY = chart1$model$sdY,
Y.hat.method = "mean",
ARL0 = 360, side = "right-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE)
Y
Y.hat
ewma
ewma
lim.tr
undebug(Ph2BayesianLASSO.EWMA)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = 100, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "mean", side = "right-sided", FAP0 = 0.01)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT1 <- 200
TT2 <- 100
w <- 7
q <- 5
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 / 2) + w - 1, delta = 0.25, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = 100, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
X1 <- X[1:TT1, ]
X2 <- X[(TT1 + 1):(TT1 + TT2), ]
X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
chart1 <- Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, const = 1, nsim.chart = 10000, Y.hat.method = "mean", side = "right-sided", FAP0 = 0.01)
chart2 <- Ph2BayesianLASSO.EWMA(Y2, chart1$model, lambda = 0.05, w = w, H = H2sim, X = X2sim,
Y1 = Y1[(q + w):TT1], X1 = X1[(q + w):TT1, ], H1 = H1[(q + w):TT1, ],
log = TRUE, const = 1, sta = TRUE, meanY = chart1$model$meanY, sdY = chart1$model$sdY,
Y.hat.method = "mean",
ARL0 = 360, side = "right-sided", max.length = 5000,
nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
