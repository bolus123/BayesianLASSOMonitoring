tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adjalp(bb$Y.tr)
bb$Y.tr
adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr, c(0.001899412, 1-0.001899412))
}
aa
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(0.001899412, 1-0.001899412))
}
aa
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
bb <- GibbsRFLSM.sim.ph1(10000, result$Y1$Y, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa,
NULL, result$Gamma, result$Tau)
adja <- adjalp(bb$Y.tr)
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
dim(result$Y1)
dim(result$Y1$Y)
length(result$Y1$Y)
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
cc1 <- BayesianLASSOMonitoring::backtrans(result$Y1$Y, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
bb1 <- BayesianLASSOMonitoring::backtrans(bb$Y.tr, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
adja <- adjalp(bb1)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb1[i, ], c(adja, 1-adja))
}
plot(cc1)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
aa[, 1]
cc1
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
side = side, tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adja
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja / 2, 1-adja / 2))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
(aa[, 1] <= result$Y1$Y) & (result$Y1$Y <= aa[, 2])
result$Y1$Y <= aa[, 2]
result$Y1$Y
aa[, 2]
result$Y1$Y <= aa[, 2]
(aa[, 1] <= result$Y1$Y[6:183]) & (result$Y1$Y[6:183] <= aa[, 2])
Rcpp::compileAttributes()
Rcpp::compileAttributes()
Rcpp::compileAttributes()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
debug(Ph1BayesianLASSO)
library(BayesianLASSOMonitoring)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(
Y, H = H, X = cbind(X1, X2), q = q,
nsim = nsim, burnin = burnin
)
Y
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
model$meanY
model$sdY
backtrans(Y.tr.sim, log, const, sta, model$meanY,
model$sdY)
debug(backtrans)
backtrans(Y.tr.sim, log, const, sta, model$meanY,
model$sdY)
sdY
out
ut * sdY
out * sdY
sdY
out
Y
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
debug(Ph1BayesianLASSO)
library(BayesianLASSOMonitoring)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
dim(Y.tr.sim)
adja.ma
adja.tr
lim.tr
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
TT
dim(Y.tr.sim)
dim(lim.tr)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
debug(Ph1BayesianLASSO)
debug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
#result <- BayesianLASSOMonitoring::GibbsRFLSM.count(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
adja.tr
adja.ma
sig.tr
sig.ma
result
result$sig.tr
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
#result <- BayesianLASSOMonitoring::GibbsRFLSM.count(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
#result <- BayesianLASSOMonitoring::GibbsRFLSM.count(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
c(min(lim.tr, model$Y.tr), max(lim.tr,
model$Y.tr))
?min
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
#result <- BayesianLASSOMonitoring::GibbsRFLSM.count(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
183/2
result$sig.tr
undebug(BayesianLASSOMonitoring::Ph1BayesianLASSO)
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 0.5, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
result <- BayesianLASSOMonitoring::Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
result$sig.tr
Ph1BayesianLASSO <- function(Y, w = 28, H = NULL, X = NULL, Y0 = rep(mean(Y), w - 1), q = 5,
A = diag(nrow = q + ifelse(is.null(X), 0, dim(X)[2])),
a = 0.1, b = 0.1, alpha = 0.1, beta = 0.1,
theta1 = 1, theta2 = 1, xi2 = 0.1,
method = "MonoALASSO", bound0 = Inf, boundqplus1 = 0,
nsim = 1000, by = 1, burnin = 1000, tol = 1e-10,
log = TRUE, const = 1, sta = TRUE,
FAP0 = 0.3, side = "two-sided",
interval = c(0.00001, 0.4), nsim.chart = 10000, tol.chart = 1e-6,
plot = TRUE) {
TT <- length(Y)
model <- GibbsRFLSM.count(Y, w, H, X, Y0, q,
A, a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin, tol,
log, const, sta)
Y.tr.sim <- GibbsRFLSM.sim.ph1(nsim.chart, model$Y.tr,
model$Phi, model$muq, model$sigma2,
X, model$Beta, model$Kappa,
NULL, NULL, NULL)$Y.tr
Y.ma.sim <- backtrans(Y.tr.sim, log, const, sta, model$meanY, model$sdY)
Y.ma.sim[Y.ma.sim < 0] <- 0
adja.tr <- adjalp(Y.tr.sim, FAP0, side, interval, tol.chart)
adja.ma <- adjalp(Y.ma.sim, FAP0, side, interval, tol.chart)
lim.tr <- matrix(NA, nrow = TT, ncol = 2)
lim.ma <- lim.tr
for (i in (q + 1):TT) {
if (side == "two-sided") {
lim.tr[i, ] <- quantile(Y.tr.sim[i - q, ], c(adja.tr / 2, 1 - adja.tr / 2))
lim.ma[i, ] <- quantile(Y.ma.sim[i - q, ], c(adja.ma / 2, 1 - adja.ma / 2))
} else if (side == "right-sided") {
lim.tr[i, 1] <- -Inf
lim.ma[i, 1] <- -Inf
lim.tr[i, 2] <- quantile(Y.tr.sim[i - q, ], c(1 - adja.tr))
lim.ma[i, 2] <- quantile(Y.ma.sim[i - q, ], c(1 - adja.ma))
} else if (side == "left-sided") {
lim.tr[i, 1] <- quantile(Y.tr.sim[i - q, ], c(adja.tr))
lim.ma[i, 1] <- quantile(Y.ma.sim[i - q, ], c(adja.ma))
lim.tr[i, 2] <- Inf
lim.ma[i, 2] <- Inf
}
}
sig.tr <- (lim.tr[, 1] <= model$Y.tr) & (model$Y.tr <= lim.tr[, 2])
sig.ma <- (lim.ma[, 1] <= model$Y.ma) & (model$Y.ma <= lim.ma[, 2])
if (plot == TRUE) {
plot(c(1, TT), c(min(lim.tr, model$Y.tr, na.rm = TRUE), max(lim.tr, model$Y.tr, na.rm = TRUE)), type = 'n',
main = "Phase I Chart for Transformed Moving Averages",
ylab = "Transformed Moving Averages",
xlab = "")
points(model$Y.tr, type = 'o')
points(1:TT[which(sig.tr == FALSE)], model$Y.tr[which(sig.tr == FALSE)], col = 'red')
points(lim.tr[, 1], type = 'l', lty = 2, col = 'red')
points(lim.tr[, 2], type = 'l', lty = 2, col = 'red')
plot(c(1, TT), c(min(lim.ma, model$Y.ma, na.rm = TRUE), max(lim.ma, model$Y.ma, na.rm = TRUE)), type = 'n',
main = "Phase I Chart for Moving Averages",
ylab = "Moving Averages",
xlab = "")
points(model$Y.ma, type = 'o')
points(1:TT[which(sig.ma == FALSE)], model$Y.ma[which(sig.ma == FALSE)], col = 'red')
points(lim.ma[, 1], type = 'l', lty = 2, col = 'red')
points(lim.ma[, 2], type = 'l', lty = 2, col = 'red')
}
out <- list("model" = model, "lim.tr" = lim.tr, "lim.ma" = lim.ma,
"sig.tr" = sig.tr, "sig.ma" = sig.ma)
out
}
remove.packages("BayesianLASSOMonitoring")
