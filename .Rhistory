out[i] <- out[i] + VGAM::rzipois(1, lambda1, pi1)
} else {
out[i] <- out[i] + VGAM::rzipois(1, lambda, pi)
}
}
out[(burnin + q + 1):(n + burnin + q)]
}
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
delta
pars
X <- 3
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
plot(aa)
X
X
pars
X <- 6
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
plot(aa)
rzinpoisinar3 <- function(n, alpha, lambda, pi, h, delta, burnin = 100) {
q <- length(alpha)
out <- rep(NA, n + burnin + q)
out[1:q] <- VGAM::rzipois(q, lambda, pi)
k <- 0
pi1 <- pi1f(delta, lambda, pi)
lambda1 <- lambda1f(delta, lambda, pi)
for (i in (q + 1):(n + burnin + q)) {
for (j in 1:q) {
out[i] <- rbinom(1, out[i - j], alpha[j])
}
if (i >= (q + 1 + burnin)) {
k <- k + 1
}
if (k >= h) {
out[i] <- out[i] + VGAM::rzipois(1, lambda1, pi1)
} else {
out[i] <- out[i] + VGAM::rzipois(1, lambda, pi)
}
}
out[(burnin + q + 1):(n + burnin + q)]
}
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1, isPhi = TRUE) {
if (isPhi == TRUE) {
Check <- invert.q(parsVec)
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
return(Mat)
}
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3], isPhi = FALSE)
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
#' simulate realizations using ARMA(p, q) and one sustained shift
#'
#' @param n is the length
#' @param phi is the alpha
#' @param theta is the mean of poisson mixture
#' @param sigma2 is the mean of poisson mixture
#' @param h is the proportion of zeros
#' @param delta is the start point of shift
#' @param burnin is the length of the burn-in period
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
rarma <- function(object, n, h, delta, xreg = NULL, nsim = 100, burnin = 50, lowerbound = 0) {
tmpint <- grep("intercept", names(object$coef))
mu <- rep(ifelse(length(tmpint) == 0, 0, object$coef[tmpint]), n)
mu[h:n] <- mu[h:n] + sqrt(object$sigma2) * delta
ts <- simulate(object, nsim = n, future = FALSE, xreg = xreg)
ts <- ts + mu
#innov <- rnorm(n, mu, sqrt(object$sigma2))
#ts <- simulate(object, nsim = n, future = FALSE, innov = innov, xreg = xreg)
ts[which(ts < lowerbound)] <- lowerbound
ts
}
load(file = "C:/Users/bolus/Box/2023 Summer/BayesianMonitoring/dataset/walker_BUPRENORPHINE_model.Rdat")
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_HYDROCODONE_model2.Rdat")
object <- walker_HYDROCODONE_model2
nnsim <- 1
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
devtools::install_github("bolus123/BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X
X <- 6
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
Y
plot(Y)
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_HYDROCODONE_model2.Rdat")
object <- walker_HYDROCODONE_model2
nnsim <- 1
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
Y
plot(Y)
X
delta
X
dleta
pars
X <- 20
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
plot(Y)
Y
delta
mean(Y[1:100])
mean(Y[201:300])
mean(Y[201:400])
mean(Y[201:500])
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
BayesianLASSOMonitoring::rarma
aa <- BayesianLASSOMonitoring::getHMatMT(10, 5)
aa
aa <- BayesianLASSOMonitoring::getHMatSustained(10, 5)
aa
aa <- BayesianLASSOMonitoring::getHMatMT(10, 5)
aa <- BayesianLASSOMonitoring::getHMatMT(93, 5)
aa
?seq
seq(1, 92, 7)
aa
dim(aa)
365.25/4
92 / 7
aa <- getHMatMT(92, 5)
aa <- BayesianLASSOMonitoring::getHMatMT(92, 5)
aa
aa[, seq(1, 92, 7)]
dim(aa)
aa[, seq(1, 92 - 5, 7)]
aa1 <- aa[, seq(1, 92 - 5, 7)]
aa2 <- aa1[, -c(colSums(aa1) < 7)]
aa2
dim(aa2)
aa2[, 12]
aa2[, 11]
colSums(aa1)
dim(aa2)
dim(aa1)
aa1 <- aa[, seq(1, 92 - 5, 7)]
aa1
dim(aa1)
aa1[, 13]
aa2 <- aa1[, -c(colSums(aa1) < 7)]
aa2
dim(aa2)
aa2[, 12]
colSums(aa1) < 7
length(colSums(aa1) < 7)
aa2 <- aa1[, -c(which(colSums(aa1) < 7))]
aa2
dim(aa2)
aa2[, 12]
runmed
?runmed
runmed(chart1$model$Mu)
runmed(rowMeans(chart1$model$Mu))
runmed(rowMeans(chart1$model$Mu), 3)
?arima
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
arimaxcpp(Y1, 5, X1)
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
arimaxcpp(Y1, 5, X1)
X1
X
Y1
}
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(1, TT1 - q, 7)]
H1 <- H1[, -c(colSums(H1) < 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
arimaxcpp(Y1, 5, X1)
Y1
X1 <- 1:length(Y1)
arimaxcpp(Y1, 5, X1)
arimaxcpp(Y1, 5, as.matrix(X1))
aa <- arimaxcpp(Y1, 5, as.matrix(X1))
aa$coef
aa$coef[1]
aa$coef[2]
aa$coef[3]
aa$coef[4]
aa$coef[5]
aa$coef[6]
aa$coef[7]
as.numeric(aa$coef[7])
H1
H1
t(H1) %*% H1
solve(t(H1) %*% H1)
solve(t(H1) %*% H1) %*% H1
solve(t(H1) %*% H1) %*% t(H1)
solve(t(H1) %*% H1) %*% t(H1) %*% Y1
aa <- arima(Y1, c(5, 0, 0))
aa$residuals
Rcpp::compileAttributes()
