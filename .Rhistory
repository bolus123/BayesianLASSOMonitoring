plot(ee[, 2])
plot(ee[, 3])
plot(ee[, 4])
plot(ee[, 5])
plot(ee[, 6])
plot(ee[, 7])
muqhat
Phihat
Phihat <- c(median(result$Phi[1, ]), median(result$Phi[2, ]), median(result$Phi[3, ]),
median(result$Phi[4, ]), median(result$Phi[5, ]))
muqhat <- median(result$muq)
sigma2hat <- median(result$sigma2)
Betahat <- c(median(result$Beta[1, ]), median(result$Beta[2, ]), median(result$Beta[3, ]),
median(result$Beta[4, ]), median(result$Beta[5, ]), median(result$Beta[6, ]))
Kappahat <- c(median(result$Kappa[1, ]), median(result$Kappa[2, ]), median(result$Kappa[3, ]),
median(result$Kappa[4, ]), median(result$Kappa[5, ]), median(result$Kappa[6, ]))
muqhat
X
Betahat
Kappahat
sigma2hat
xx <- GibbsRFLSM.sim.ph2(TT, nsim, 1, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
xx <- GibbsRFLSM.sim.ph2(TT, 1000, 1, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
xx <- GibbsRFLSM.sim.ph2(TT, 1000, 1, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
xx
xx[, 1]
xx[, 2]
xx$Y.tr[, 1]
plot(Y)
points(xx[, 1], col = 'red')
dim(xx)
dim(xx$Y.tr)
xx <- GibbsRFLSM.sim.ph2(TT - q, 1000, 1, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
warnings
warings()
warnings()
debug(GibbsRFLSM.sim.ph2)
xx <- GibbsRFLSM.sim.ph2(TT - q, 1000, 1, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
m
tmpsel
dim(Phi)
muq
muX[, tmpsel]
muH[, tmpsel]
Phi[, tmpsel]
muq[tmpsel] + muX[, tmpsel] + muH[, tmpsel]
muq[tmpsel]
muX[, tmpsel] + muH[, tmpsel]
length(muX[, tmpsel])
length(muH[, tmpsel])
debug(GibbsRFLSM.sim.ph2)
xx <- GibbsRFLSM.sim.ph2(TT - q, 1000, 1, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa, NULL, NULL, NULL,
result$Y1$Y[1:5], NULL, NULL)
h
dim(muH)
dim(muX)
dim(X)
GibbsRFLSM.sim.ph2
?GibbsRFLSM.sim.ph2
H
dim(H)
xx <- GibbsRFLSM.sim.ph2(TT - q, 1000, 1, result$Phi, result$muq, result$sigma2,
X[6:183, ], result$Beta, result$Kappa, NULL, NULL, NULL,
result$Y1$Y[1:5], X[1:5, ], NULL)
xx$Y.tr
dim(xx$Y.tr)
plot(result$Y1$Y)
points(6:183, xx$Y.tr[, 1], col = 'red')
points(6:183, xx$Y.tr[, 2], col = 'red')
points(6:183, xx$Y.tr[, 3], col = 'red')
points(6:183, xx$Y.tr[, 4], col = 'red')
points(6:183, xx$Y.tr[, 5], col = 'red')
bb
bb$Y.tr[, 1]
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
bb <- GibbsRFLSM.sim.ph1(10000, result$Y1$Y, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa,
NULL, result$Gamma, result$Tau)
bb$Y.tr[, 1]
bb$Y.tr[, 2]
bb$Y.tr[, 3]
bb$Y.tr[, 4]
bb$Y.tr[, 5]
bb$Y.tr[, 6]
bb1 <- BayesianLASSOMonitoring::backtrans(bb$Y.tr, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
bb1
bb1[, 1]
bb1[, 2]
bb1[, 3]
bb1
bb1[, 1]
cc1 <- BayesianLASSOMonitoring::backtrans(result$Y1$Y, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
cc1
plot(cc1)
points(bb1[, 1])
points(bb1[, 1], col = 'red')
points(bb1[, 2], col = 'red')
ff <- residual.stat(result$Y1$Y, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat)
ff
bb1
bb1[, 1]
cc1
cc1[, 1]
cc1
Phihat
debug(residual.stat)
ff <- residual.stat(result$Y1$Y, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat)
Muhat
Y.tr
Y.tr - Muhat
fit
(V[i] - fit[i - q])
tmp
xx
bb1
result$Y1$Y
plot(result$Y1$Y)
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
points(bb$Y.tr[, 6], col = 'red')
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
points(bb$Y.tr[, 6], col = 'red')
points(bb$Y.tr[, 7], col = 'red')
points(bb$Y.tr[, 8], col = 'red')
points(bb$Y.tr[, 9], col = 'red')
points(bb$Y.tr[, 10], col = 'red')
points(cc$Y.tr[, 5], col = 'blue')
points(cc$Y.tr[, 1], col = 'blue')
points(cc$Y.tr[, 2], col = 'blue')
points(cc$Y.tr[, 3], col = 'blue')
points(cc$Y.tr[, 4], col = 'blue')
points(cc$Y.tr[, 5], col = 'blue')
points(cc$Y.tr[, 6], col = 'blue')
points(cc$Y.tr[, 7], col = 'blue')
points(cc$Y.tr[, 8], col = 'blue')
points(cc$Y.tr[, 9], col = 'blue')
points(cc$Y.tr[, 10], col = 'blue')
cc$Y.tr[1, ]
dim(cc$Y.tr[1, ])
dim(cc$Y.tr)
quantile(cc$Y.tr[1, ], c(0.025, 0.975))
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.tr)[2]
TT <- dim(Y.tr)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
debug(adjalp)
adjalp(bb$Y.tr)
debug(root.finding)
tmplower
tmpupper
tmplower
tmpupper
(tmplower <= Y.sim[, i])
(tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)
(tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
?uniroot
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 0.001) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adjalp(bb$Y.tr)
bb$Y.tr
adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr, c(0.001899412, 1-0.001899412))
}
aa
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(0.001899412, 1-0.001899412))
}
aa
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
bb <- GibbsRFLSM.sim.ph1(10000, result$Y1$Y, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa,
NULL, result$Gamma, result$Tau)
adja <- adjalp(bb$Y.tr)
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
dim(result$Y1)
dim(result$Y1$Y)
length(result$Y1$Y)
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
cc1 <- BayesianLASSOMonitoring::backtrans(result$Y1$Y, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
bb1 <- BayesianLASSOMonitoring::backtrans(bb$Y.tr, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
adja <- adjalp(bb1)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb1[i, ], c(adja, 1-adja))
}
plot(cc1)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
aa[, 1]
cc1
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
side = side, tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adja
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja / 2, 1-adja / 2))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
(aa[, 1] <= result$Y1$Y) & (result$Y1$Y <= aa[, 2])
result$Y1$Y <= aa[, 2]
result$Y1$Y
aa[, 2]
result$Y1$Y <= aa[, 2]
(aa[, 1] <= result$Y1$Y[6:183]) & (result$Y1$Y[6:183] <= aa[, 2])
Rcpp::compileAttributes()
Rcpp::compileAttributes()
Rcpp::compileAttributes()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
