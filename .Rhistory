} else if (side == "left-sided") {
p.value <- p.value.left
lower <- quantile(tmpY.resi.min, FAP0)
upper <- NA
sig.ind <- Y.resi <= lower
} else {
p.value <- p.value.two
lower <- quantile(tmpY.resi.min, FAP0 / 2)
upper <- quantile(tmpY.resi.max, 1 - FAP0 / 2)
sig.ind <- (Y.resi <= lower) | (Y.resi >= upper)
}
sig <- p.value <= FAP0
sig.ind <-
if (side == "right-sided")
list(sig = sig,
p.value = p.value,
sig.ind = sig.ind,
cs = Y.resi,
lower = lower,
upper = upper,
Y0.median = tmpY.sim.median,
p.value.right = p.value.right,
p.value.left = p.value.left,
p.value.two = p.value.two)
}
chart11 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y0(chart1$model, nsim = 10000, FAP0 = FAP0, log = log, sta = sta, lowerbound = 0, side = side)
chart11 <- Ph1MultipleTesting.Y0(chart1$model, nsim = 10000, FAP0 = FAP0, log = log, sta = sta, lowerbound = 0, side = side)
chart11
out <- rep(NA, 6)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$model$Phi)[1]
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q + w - 1
TP.app <- sum(chart11$sig.ind[start.exact:end], na.rm =TRUE)ÃŸ
out <- rep(NA, 6)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$model$Phi)[1]
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q + w - 1
TP.app <- sum(chart11$sig.ind[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart11$sig.ind[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig.tr <- chart11$sig
sig <- sig.tr
#debug( BayesianLASSOMonitoring::RMSE.ph1)
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph1.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, X2, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph2.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
out <- c(sig,
sensitivity.app,
specificity.app,
ppv.app,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
out
out <- NA
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1, X1, X2)
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1, X1, X2) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, X1, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none",
nsim = 300, by = 10, burnin = 3000 / 0.8 * 0.2), silent = TRUE)
chart11 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y0(chart1$model, nsim = 10000, FAP0 = FAP0, log = log, sta = sta, lowerbound = 0, side = side)
out <- rep(NA, 6)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$model$Phi)[1]
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q + w - 1
TP.app <- sum(chart11$sig.ind[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart11$sig.ind[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig.tr <- chart11$sig
sig <- sig.tr
#debug( BayesianLASSOMonitoring::RMSE.ph1)
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph1.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, X2, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph2.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
out <- c(sig,
sensitivity.app,
specificity.app,
ppv.app,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
return(out)
}
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1, X1, X2)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none",
nsim = 300, by = 10, burnin = 3000 / 0.8 * 0.2), silent = TRUE)
chart11 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y0(chart1$model, nsim = 10000, FAP0 = FAP0, log = log, sta = sta, lowerbound = 0, side = side)
out <- rep(NA, 6)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$model$Phi)[1]
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q + w - 1
TP.app <- sum(chart11$sig.ind[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart11$sig.ind[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig.tr <- chart11$sig
sig <- sig.tr
#debug( BayesianLASSOMonitoring::RMSE.ph1)
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph1.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, X2, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph2.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
out <- c(sig,
sensitivity.app,
specificity.app,
ppv.app,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
return(out)
}
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 1
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
#X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
#X1 <- X[1:TT1, ]
#X2 <- X[(TT1 + 1):(TT1 + TT2), ]
#X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
out <- rep(NA, 18 * 6)
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
getChart <- function(Y1, w, H1, Y0, method,
side, FAP0,
log, sta, Y2, H2, tt, TT1) {
chart1 <- try(BayesianLASSOMonitoring::Ph1BayesianLASSO(Y1, w, H1, NULL, Y0 = Y0, method = method,
const = 1, side = side, FAP0 = FAP0,
log = log, sta = sta, plot = TRUE,
sign.method = "DM", adj.method = "none",
nsim = 300, by = 10, burnin = 3000 / 0.8 * 0.2), silent = TRUE)
chart11 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y0(chart1$model, nsim = 10000, FAP0 = FAP0, log = log, sta = sta, lowerbound = 0, side = side)
out <- rep(NA, 6)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$model$Phi)[1]
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q + w - 1
TP.app <- sum(chart11$sig.ind[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart11$sig.ind[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart11$sig.ind[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig.tr <- chart11$sig
sig <- sig.tr
#debug( BayesianLASSOMonitoring::RMSE.ph1)
tmp <- BayesianLASSOMonitoring::RMSE.ph1(chart1$model, log = log, sta = sta)
RMSE.ph1.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph1.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
tmp <- BayesianLASSOMonitoring::RMSE.ph2(Y2, chart1$model, NULL, H2, log = log, sta = sta)
RMSE.ph2.tr <- median(tmp$RMSE.tr, na.rm =TRUE)
RMSE.ph2.ma <- median(tmp$RMSE.ma, na.rm =TRUE)
out <- c(sig,
sensitivity.app,
specificity.app,
ppv.app,
RMSE.ph1.ma,
RMSE.ph2.ma)
}
return(out)
}
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out1
out <- rep(NA, 6 * 6)
out1 <- getChart(Y1, w, H1, Y0, "MT",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out2 <- getChart(Y1, w, H1, Y0, "regression",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out3 <- getChart(Y1, w, H1, Y0, "LASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out4 <- getChart(Y1, w, H1, Y0, "ALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out5 <- getChart(Y1, w, H1, Y0, "MonoLASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out6 <- getChart(Y1, w, H1, Y0, "MonoALASSO",
side, FAP0,
log, sta, Y2, H2, tt, TT1)
out <- c(out1, out2, out3, out4, out5, out6)
out
load(file = "C:/Users/yyao17/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
tmpout <- list()
for (i in 1:2000) {
addr <- "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/New folder/tmp1/"
file.addr <- paste(addr, "sim", i, ".Rdat", sep = "")
if (file.exists(file.addr)) {
load(file.addr)
tmpout[[i]] <- out
rm(out)
}
}
tmpout
nnsim0 <- 100
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars1 <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim0)
tt <- dim(pars1)[1]
out.mat <- matrix(NA, nrow = tt, ncol = length(tmpout[[1]]))
for (i in 1:1948) {
if (!is.null(tmpout[[i]])) {
out.mat[i, ] <- tmpout[[i]]
}
}
nnsim <- 1
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars2 <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
tt <- dim(pars2)[1]
sig <- matrix(NA, nrow = tt, ncol = 6)
median.RMSE.ph1 <- matrix(NA, nrow = tt, ncol = 7)
median.RMSE.ph2 <- matrix(NA, nrow = tt, ncol = 7)
for (i in 1:tt) {
tmpsel <- which((pars1[, 1] == pars2[i, 1]) & (pars1[, 2] == pars2[i, 2]) & (pars1[, 3] == pars2[i, 3]) & (pars1[, 4] == pars2[i, 4]) & (pars1[, 5] == pars2[i, 5]) &
(pars1[, 6] == pars2[i, 6]) & (pars1[, 7] == pars2[i, 7]) & (pars1[, 8] == pars2[i, 8]) & (pars1[, 9] == pars2[i, 9]) & (pars1[, 10] == pars2[i, 10]) &
(pars1[, 11] == pars2[i, 11]))
tmp <- out.mat[tmpsel, ]
r <- 0
for (j in 1:6) {
for (k in 1:1) {
r <- r + 1
sig[i, r] <- mean(tmp[, k + (j - 1) * 6], na.rm = TRUE)
}
}
for (j in 1:6) {
median.RMSE.ph1[i, j] <- median(tmp[, 5 + (j - 1) * 6], na.rm = TRUE)
median.RMSE.ph2[i, j] <- median(tmp[, 6 + (j - 1) * 6], na.rm = TRUE)
}
median.RMSE.ph1[i, 7] <- median(tmp[, 37], na.rm = TRUE)
median.RMSE.ph2[i, 7] <- median(tmp[, 38], na.rm = TRUE)
}
sig <- cbind(pars2, sig)
median.RMSE.ph1 <- cbind(pars2, median.RMSE.ph1)
median.RMSE.ph2 <- cbind(pars2, median.RMSE.ph2)
sig
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
GibbsRFLSM <- function(Y, H = NULL, X = NULL, q = 5,
A = diag(nrow = q),
a = 0.1, b = 0.1, alpha = 0.1, beta = 0.1,
theta1 = 1, theta2 = 1, xi2 = 0.1,
method = "MonoALASSO", bound0 = Inf, boundqplus1 = 0,
nsim = 1000, by = 1, burnin = 1000, tol = 1e-10) {
TT <- length(Y)
if (is.null(H) && is.null(X)) {
model <- GibbsRFLSMcpp(Y, q,
A, a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin,
tol)
} else {
H1 <- cbind(H, X)
model <- GibbsRFLSMcpp(Y, q,
A, a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin,
tol, H1)
}
if (is.null(H)) {
m <- 0
Gamma <- NA
Tau <- NA
pGamma <- NA
muGamma <- NA
sigma2Gamma <- NA
} else {
m <- dim(H)[2]
Gamma <- model$Gamma[1:m, ]
Tau <- model$Tau[1:m, ]
pGamma <- model$p[1:m, ]
muGamma <- model$muGamma[1:m, ]
sigma2Gamma <- model$sigma2Gamma[1:m, ]
}
if (is.null(X)) {
p <- 0
Beta <- NA
Kappa <- NA
pBeta <- NA
muBeta <- NA
sigma2Beta <- NA
} else {
p <- dim(X)[2]
Beta <- model$Gamma[(m + 1):(m + p), ]
Kappa <- model$Tau[(m + 1):(m + p), ]
pBeta <- model$p[(m + 1):(m + p), ]
muBeta <- model$muGamma[(m + 1):(m + p), ]
sigma2Beta <- model$sigma2Gamma[(m + 1):(m + p), ]
}
out <- list(
"Phi" = matrix(model$Phi, ncol = nsim),
"Beta" = matrix(Beta, ncol = nsim),
"pBeta" = matrix(pBeta, ncol = nsim),
"muBeta" = matrix(muBeta, ncol = nsim),
"sigma2Beta" = matrix(sigma2Beta, ncol = nsim),
"Kappa" = matrix(Kappa, ncol = nsim),
"Gamma" = matrix(Gamma, ncol = nsim),
"pGamma" = matrix(pGamma, ncol = nsim),
"muGamma" = matrix(muGamma, ncol = nsim),
"sigma2Gamma" = matrix(sigma2Gamma, ncol = nsim),
"Tau" = matrix(Tau, ncol = nsim),
"sigma2" = model$sigma2,
"lambda2" = model$lambda2,
"muq" = model$muq,
"Mu" = model$Mu
)
return(out)
}
#' Random Flexible Level Shift Model
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param Y is a vector.
#' @param H is the design matrix for shifts.
#' @param X is the input matrix
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the slab-and-spike coefficients.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda2.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau and Kappa.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau and Kappa.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is an upper bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a lower bound of the methods with Monotonicity constrains.
#' @param nsim is the number of draws from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance level.
#' @param log is the flag triggering the log transformation
#' @param const is the constant added to the input during the log transformation
#' @param sta is the flag triggering the standardization
#' @references McCulloch, R. E., & Tsay, R. S. (1993). Bayesian inference and prediction for mean and variance shifts in autoregressive time series. Journal of the american Statistical association, 88(423), 968-978.
#'
#'
#' @export
#' @examples
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = 100)
#'
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM.ma(Y, H = H, q = q, nsim = nsim, burnin = burnin)
#'
GibbsRFLSM.ma <- function(Y, w = 7, H = NULL, X = NULL, Y0 = rep(mean(Y), w - 1), q = 5,
A = diag(nrow = q),
a = 0.1, b = 0.1, alpha = 0.1, beta = 0.1,
theta1 = 1, theta2 = 1, xi2 = 0.1,
method = "MonoALASSO", bound0 = Inf, boundqplus1 = 0,
nsim = 1000, by = 1, burnin = 1000, tol = 1e-10,
log = TRUE, const = 1, sta = TRUE) {
YY <- c(Y0, Y)
TT <- length(Y)
nn <- length(YY)
####################################
Y1 <- movaver(YY, w)[(nn - TT + 1):nn]
Y1.ma <- Y1
Y2 <- trans(Y1, log = log, const = const, sta = sta)
Y1 <- Y2$Y
####################################
model <- GibbsRFLSM(Y1, H, X, q,
A,
a, b, alpha, beta,
theta1, theta2, xi2,
method, bound0, boundqplus1,
nsim, by, burnin, tol)
if (w == 1) {
tmpY0 <- NULL
} else {
tmpY0 <- YY[(nn - TT - (w - 1) + 1):(nn - TT)]
}
out <- list(
"Phi" = model$Phi,
"Beta" = model$Beta,
"pBeta" = model$pBeta,
"muBeta" = model$muBeta,
"sigma2Beta" = model$sigma2Beta,
"Kappa" = model$Kappa,
"Gamma" = model$Gamma,
"pGamma" = model$pGamma,
"muGamma" = model$muGamma,
"sigma2Gamma" = model$sigma2Gamma,
"Tau" = model$Tau,
"sigma2" = model$sigma2,
"lambda2" = model$lambda2,
"muq" = model$muq,
"Mu" = model$Mu,
"w" = w,
"Y.tr" = Y2$Y,
"meanY" = Y2$meanY,
"sdY" = Y2$sdY,
"Y.ma" = Y1.ma,
"X" = X,
"H" = H,
"Y" = Y,
"Y0" = tmpY0
)
return(out)
}
remove.packages("BayesianLASSOMonitoring")
