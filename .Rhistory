out[2] <- -b + sqrt(d)
out <- out / 2 / a
out[out >= mu0][1]
}
sigma21f <- function(delta, lambda0, pi0) {
c0 <- (1 + pi0 * lambda0)
mu1 <- mu1f(delta, lambda0, pi0)
c0 * mu1
}
pi1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
sigma21 <- sigma21f(delta, lambda0, pi0)
pi1 <- 1 - mu1 ^ 2 / (sigma21 - mu1 + mu1 ^ 2)
pi1
}
mu1f(0, 0.239385, 0.1453097)
sigma21f(0, 0.239385, 0.1453097)
(1 + 0.1453097 * 0.239385) * (1 - 0.1453097) * 0.239385
pi1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
sigma21 <- sigma21f(delta, lambda0, pi0)
pi1 <- 1 - mu1 ^ 2 / (sigma21 - mu1 + mu1 ^ 2)
pi1
}
pi1f(0, 0.239385, 0.1453097)
pi1f(0.5, 0.239385, 0.1453097)
mu1f <- function(delta, lambda0, pi0) {
mu0 <- (1 - pi0) * lambda0
c0 <- (1 + pi0 / (1 - pi0) * mu0)
b <- - (2 * mu0 + delta ^ 2 * c0)
c <- mu0 ^ 2
a <- 1
d <- b ^ 2 - 4 * a * c
out <- rep(NA, 2)
out[1] <- -b - sqrt(d)
out[2] <- -b + sqrt(d)
out <- out / 2 / a
out[out >= mu0][1]
}
sigma21f <- function(delta, lambda0, pi0) {
c0 <- (1 + pi0 * lambda0)
mu1 <- mu1f(delta, lambda0, pi0)
c0 * mu1
}
pi1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
sigma21 <- sigma21f(delta, lambda0, pi0)
pi1 <- 1 - mu1 ^ 2 / (sigma21 - mu1 + mu1 ^ 2)
pi1
}
lambda1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
pi1 <- pi1f(delta, lambda0, pi0)
lambda1 <- mu1 / (1 - pi1)
lambda1
}
lambda1f(0.5, 0.239385, 0.1453097)
lambda1f(0, 0.239385, 0.1453097)
mu1f <- function(delta, lambda0, pi0) {
mu0 <- (1 - pi0) * lambda0
c0 <- (1 + pi0 / (1 - pi0) * mu0)
b <- - (2 * mu0 + delta ^ 2 * c0)
c <- mu0 ^ 2
a <- 1
d <- b ^ 2 - 4 * a * c
out <- rep(NA, 2)
out[1] <- -b - sqrt(d)
out[2] <- -b + sqrt(d)
out <- out / 2 / a
out[out >= mu0][1]
}
sigma21f <- function(delta, lambda0, pi0) {
c0 <- (1 + pi0 * lambda0)
mu1 <- mu1f(delta, lambda0, pi0)
c0 * mu1
}
pi1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
sigma21 <- sigma21f(delta, lambda0, pi0)
pi1 <- 1 - mu1 ^ 2 / (sigma21 - mu1 + mu1 ^ 2)
pi1
}
lambda1f <- function(delta, lambda0, pi0) {
mu1 <- mu1f(delta, lambda0, pi0)
pi1 <- pi1f(delta, lambda0, pi0)
lambda1 <- mu1 / (1 - pi1)
lambda1
}
#' simulate realizations using INAR(3) with zero-inflated Poisson innovation and one sustained shift
#'
#' @param n is the length
#' @param alpha is the alpha
#' @param lambda is the mean of poisson mixture
#' @param pi is the proportion of zeros
#' @param h is the start point of shift
#' @param delta is the value of the standardized shift
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
rzinpoisinar3 <- function(n, alpha, lambda, pi, h, delta, burnin = 100) {
q <- length(alpha)
out <- rep(NA, n + burnin + q)
out[1:q] <- VGAM::rzipois(q, lambda, pi)
k <- 0
pi1 <- pi1f(delta, lambda, pi)
lambda1 <- lambda1f(delta, lambda, pi)
for (i in (q + 1):(n + burnin + q)) {
for (j in 1:q) {
out[i] <- rbinom(1, out[i - j], alpha[j])
}
if (i >= (q + 1 + burnin)) {
k <- k + 1
}
if (k >= h) {
out[i] <- out[i] + VGAM::rzipois(1, lambda1, pi1)
} else {
out[i] <- out[i] + VGAM::rzipois(1, lambda, pi)
}
}
out[(burnin + q + 1):(n + burnin + q)]
}
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
delta
pars
X <- 3
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
plot(aa)
X
X
pars
X <- 6
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
aa <- rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
aa
plot(aa)
rzinpoisinar3 <- function(n, alpha, lambda, pi, h, delta, burnin = 100) {
q <- length(alpha)
out <- rep(NA, n + burnin + q)
out[1:q] <- VGAM::rzipois(q, lambda, pi)
k <- 0
pi1 <- pi1f(delta, lambda, pi)
lambda1 <- lambda1f(delta, lambda, pi)
for (i in (q + 1):(n + burnin + q)) {
for (j in 1:q) {
out[i] <- rbinom(1, out[i - j], alpha[j])
}
if (i >= (q + 1 + burnin)) {
k <- k + 1
}
if (k >= h) {
out[i] <- out[i] + VGAM::rzipois(1, lambda1, pi1)
} else {
out[i] <- out[i] + VGAM::rzipois(1, lambda, pi)
}
}
out[(burnin + q + 1):(n + burnin + q)]
}
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1, isPhi = TRUE) {
if (isPhi == TRUE) {
Check <- invert.q(parsVec)
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
return(Mat)
}
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3], isPhi = FALSE)
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
#' simulate realizations using ARMA(p, q) and one sustained shift
#'
#' @param n is the length
#' @param phi is the alpha
#' @param theta is the mean of poisson mixture
#' @param sigma2 is the mean of poisson mixture
#' @param h is the proportion of zeros
#' @param delta is the start point of shift
#' @param burnin is the length of the burn-in period
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
rarma <- function(object, n, h, delta, xreg = NULL, nsim = 100, burnin = 50, lowerbound = 0) {
tmpint <- grep("intercept", names(object$coef))
mu <- rep(ifelse(length(tmpint) == 0, 0, object$coef[tmpint]), n)
mu[h:n] <- mu[h:n] + sqrt(object$sigma2) * delta
ts <- simulate(object, nsim = n, future = FALSE, xreg = xreg)
ts <- ts + mu
#innov <- rnorm(n, mu, sqrt(object$sigma2))
#ts <- simulate(object, nsim = n, future = FALSE, innov = innov, xreg = xreg)
ts[which(ts < lowerbound)] <- lowerbound
ts
}
load(file = "C:/Users/bolus/Box/2023 Summer/BayesianMonitoring/dataset/walker_BUPRENORPHINE_model.Rdat")
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_HYDROCODONE_model2.Rdat")
object <- walker_HYDROCODONE_model2
nnsim <- 1
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
devtools::install_github("bolus123/BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
X
X <- 6
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
Y
plot(Y)
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_HYDROCODONE_model2.Rdat")
object <- walker_HYDROCODONE_model2
nnsim <- 1
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1, 3, 7, 14, 28)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
Y
plot(Y)
X
delta
X
dleta
pars
X <- 20
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
plot(Y)
Y
delta
mean(Y[1:100])
mean(Y[201:300])
mean(Y[201:400])
mean(Y[201:500])
