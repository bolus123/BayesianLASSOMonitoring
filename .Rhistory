plot(dat$Freq[sta2017:end2019], type = 'l', ylab = 'Frequency', xlab = '',
main = "Daily Opioid-overdose-related ER Visits \nfrom 2017 to 2019 in Walker County", xaxt='n',
col = 'darkgrey')
tmp <- c((133 - mw + 1):166, (421 - mw + 1):435, (568 - mw + 1):568)
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = 120 - 0.5, lty = 1, col = 'red')
abline(v = 166 + 0.5, lty = 1, col = 'red')
abline(v = 408 - 0.5, lty = 1, col = 'red')
abline(v = 435 + 0.5, lty = 1, col = 'red')
abline(v = 555 - 0.5, lty = 1, col = 'red')
abline(v = 568 + 0.5, lty = 1, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
points(movingaverages0 - 0.5, type = 'l', ylab = "Daily Moving Average", xlab = "", xaxt='n')
points(which(pvec > 0.9985245) + 5,
(movingaverages0 - 0.5)[which(pvec > 0.9985245) + 5],
col = 'red', pch = 16)
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'lightgrey')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
legend("topright", legend = c("ER Visit", "Moving Average", "Shift", "Investigation Window"),
lty = c(1, 1, NA, 1), col = c("darkgrey", "black", "red", "red"),
pch = c(NA, NA, 16, NA), ncol = 2)
target
shifts
shift
128 - 13
416 - 13
563 - 13
fit <- BayesianLassoMonitoring::Fit(movingaverages0, mo0$Phi, mo0$Mu)
quantileMu <- matrix(NA, nrow = dim(mo0$Mu)[1], ncol = 3)
quantilefit <- matrix(NA, nrow = dim(mo0$Mu)[1], ncol = 3)
for (i in 1:dim(mo0$Mu)[1]) {
tmp <- quantile(mo0$Mu[i, ], c(0.025, 0.5, 0.975))
quantileMu[i, ] <- tmp
tmp <- quantile(fit[i, ] - 0.5, c(0.025, 0.5, 0.975))
quantilefit[i, ] <- tmp
}
pvec <- rep(NA, dim(mo0$Gamma)[1])
for (i in 1:dim(mo0$Gamma)[1]) {
pvec[i] <- median(mo0$p[i, ])
}
plot(dat$Freq[sta2017:end2019], type = 'l', ylab = 'Frequency', xlab = '',
main = "Daily Opioid-overdose-related ER Visits \nfrom 2017 to 2019 in Walker County", xaxt='n',
col = 'darkgrey')
tmp <- c((133 - mw + 1):166, (421 - mw + 1):435, (568 - mw + 1):568)
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = 115 + 5 - 0.5, lty = 1, col = 'red')
abline(v = 161 + 5 + 0.5, lty = 1, col = 'red')
abline(v = 403 + 5 - 0.5, lty = 1, col = 'red')
abline(v = 430 + 5 + 0.5, lty = 1, col = 'red')
abline(v = 550 + 5 - 0.5, lty = 1, col = 'red')
abline(v = 563 + 5 + 0.5, lty = 1, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
points(movingaverages0 - 0.5, type = 'l', ylab = "Daily Moving Average", xlab = "", xaxt='n')
points(shift + 5,
(movingaverages0 - 0.5)[shift + 5],
col = 'red', pch = 16)
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'lightgrey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'lightgrey')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
legend("topright", legend = c("ER Visit", "Moving Average", "Shift", "Investigation Window"),
lty = c(1, 1, NA, 1), col = c("darkgrey", "black", "red", "red"),
pch = c(NA, NA, 16, NA), ncol = 2)
lower
upper
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(c(rep(NA, 5), pvec))
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'grey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'grey')
abline(h = 0.9985245, lty = 2, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
legend("topright", legend = "Cut-off (Sidak)", lty = 2, col = 'red')
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0)
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0, type = 'l', lty = 1, col = 'black')
points(movingaverages0, type = 'l', lty = 1, col = 'black')
points(upper, type = 'l', lty = 1, col = 'pink')
points(lower, type = 'l', lty = 1, col = 'pink')
length(upper)
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0, type = 'l', lty = 1, col = 'black')
points(c(rep(NA, 5), upper), type = 'l', lty = 1, col = 'pink')
points(c(rep(NA, 5), lower), type = 'l', lty = 1, col = 'pink')
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0- 0.5, type = 'l', lty = 1, col = 'black')
points(c(rep(NA, 5), upper- 0.5), type = 'l', lty = 1, col = 'pink')
points(c(rep(NA, 5), lower- 0.5), type = 'l', lty = 1, col = 'pink')
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'grey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'grey')
abline(h = 0.9985245, lty = 2, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
legend("topright", legend = "Cut-off (Sidak)", lty = 2, col = 'red')
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0- 0.5, type = 'l', lty = 1, col = 'black')
points(c(rep(NA, 5), upper- 0.5), type = 'l', lty = 1, col = 'pink')
points(c(rep(NA, 5), lower- 0.5), type = 'l', lty = 1, col = 'pink')
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'grey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'grey')
abline(h = 0.9985245, lty = 2, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
plot(c(1, 1095), c(min(lower, upper, movingaverages0), max(lower, upper, movingaverages0)), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0- 0.5, type = 'l', lty = 1, col = 'black')
points(c(rep(NA, 5), upper- 0.5), type = 'l', lty = 1, col = 'pink')
points(c(rep(NA, 5), lower- 0.5), type = 'l', lty = 1, col = 'pink')
abli
plot(c(1, 1095), c(min(lower, upper, movingaverages0) - 0.5,
max(lower, upper, movingaverages0) - 0.5), type = 'n', xlab = '',
ylab = 'Moving Average', xaxt='n', main = "Residual-based Chart")
points(movingaverages0- 0.5, type = 'l', lty = 1, col = 'black')
points(c(rep(NA, 5), upper- 0.5), type = 'l', lty = 1, col = 'pink')
points(c(rep(NA, 5), lower- 0.5), type = 'l', lty = 1, col = 'pink')
abline(v = sta2018 - sta2017 + 1, lty = 2, col = 'grey')
abline(v = sta2019 - sta2017 + 1, lty = 2, col = 'grey')
abline(h = 0.9985245, lty = 2, col = 'red')
axis(side = 1, at = c(sta2018 - sta2017 + 1,
sta2019 - sta2017 + 1,
sta2017July - sta2017 + 1,
sta2018July - sta2017 + 1,
sta2019July  - sta2017 + 1
),
labels = c("1/1/2018",
"1/1/2019",
NA,
NA,
NA))
points(shift + 5,
(movingaverages0 - 0.5)[shift + 5],
col = 'red', pch = 16)
161 - 115 + 1
430 - 403 + 1
563 - 550 + 1
#' obtain the root squared error
#'
#' @param Y is a vector
#' @param Phi is the coefficient
#' @param Mu is the mean
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' Residual(Y, result$Phi, result$Mu)
Residual <- function(Y, Phi, Mu) {
T <- length(Y)
q <- dim(Phi)[1]
nsim <- dim(Phi)[2]
ee <- matrix(NA, nrow = T - q, ncol = nsim)
for (ii in seq(nsim)) {
V <- matrix(Y, ncol = 1) - Mu[, ii]
Vas <- getV(V, q)
V <- V[-c(1:q)]
Vas <- Vas[-c(1:q), ]
ee[, ii] <- V - Vas %*% Phi[, ii]
}
ee
}
#' obtain the root squared error
#'
#' @param Y is a vector
#' @param Phi is the coefficient
#' @param Mu is the mean
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' Fit(Y, result$Phi, result$Mu)
Fit <- function(Y, Phi, Mu) {
T <- length(Y)
q <- dim(Phi)[1]
nsim <- dim(Phi)[2]
ff <- matrix(NA, nrow = T - q, ncol = nsim)
for (ii in seq(nsim)) {
V <- matrix(Y, ncol = 1) - Mu[, ii]
Vas <- getV(V, q)
V <- V[-c(1:q)]
Vas <- Vas[-c(1:q), ]
ff[, ii] <- Vas %*% Phi[, ii] + Mu[-c(1:q), ii]
}
rbind(Mu[1:q, ], ff)
}
#' obtain the root squared error
#'
#' @param Y is a vector
#' @param Phi is the coefficient
#' @param Mu is the mean
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' Fit(Y, result$Phi, result$Mu)
GibbsRFLSM.sim <- function(Y, Phi, Mu, sigma2) {
TT <- length(Y)
q <- length(Phi)
sim <- rep(NA, TT)
sim[1:q] <- Y[1:q]
for (ii in (q + 1):TT) {
sim[ii] <- Mu[ii] + (sim[(ii - 1):(ii - q)] - Mu[(ii - 1):(ii - q)]) %*%
Phi + rnorm(1, 0, sqrt(sigma2))
}
sim
}
#' obtain the root squared error
#'
#' @param Y is a vector
#' @param Phi is the coefficient
#' @param Mu is the mean
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' Fit(Y, result$Phi, result$Mu)
GibbsRFLSM.simmax.Yao <- function(Y, Phi, Mu, sigma2,
nsim = 1000) {
q <- dim(Phi)[1]
out <- rep(NA, nsim)
xbar <- mean(Y[-c(1:q)])
std <- sd(Y[-c(1:q)])
m <- dim(Phi)[2]
for (i in seq(nsim)) {
k <- sample(1:m, 1)
tmpPhi <- Phi[, k]
tmpMu <- Mu[, k]
tmpsigma2 <- sigma2[k]
tmp <- GibbsRFLSM.sim(Y, tmpPhi, tmpMu, tmpsigma2)
out[i] <- max(((tmp[-c(1:q)] - xbar) / std) ^ 2)
}
out
}
#' obtain the root squared error
#'
#' @param Y is a vector
#' @param Phi is the coefficient
#' @param Mu is the mean
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1,
#' 1, 1, 0.1, "MonoALASSO", Inf, 0, 1000, 1, 100, 1e-10, H)
#'
#' Fit(Y, result$Phi, result$Mu)
GibbsRFLSM.simmax.residual <- function(Y, Phi, Mu, sigma2,
Phihat, Muhat, sigma2hat,
nsim = 1000) {
q <- dim(Phi)[1]
out <- rep(NA, nsim)
m <- dim(Phi)[2]
for (i in seq(nsim)) {
k <- sample(1:m, 1)
tmpPhi <- Phi[, k]
tmpMu <- Mu[, k]
tmpsigma2 <- sigma2[k]
tmp <- GibbsRFLSM.sim(Y, tmpPhi, tmpMu, tmpsigma2)
tmpV <- tmp - Muhat
tmpVas <- getV(tmpV, q)
tmpV <- tmpV[-c(1:q)]
tmpVas <- tmpVas[-c(1:q), ]
out[i] <- max((tmpV - tmpVas %*% Phihat) ^ 2 / sigma2hat)
}
out
}
library(BayesianLassoMonitoring)
roxygen2::roxygenise()
library(BayesianLassoMonitoring)
devtools::install_github("bolus123/BayesianLassoMonitoring")
library(BayesianLassoMonitoring)
library(lubridate)
movaver <- function(x, n = 5){filter(x, rep(1 / n, n), sides = 1)}
dat <- read.csv(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/Yuhui R21/Daily opioid-overdose-related ER visits in Walker.csv")
load(file = '/Users/yuihuiyao/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/postermodel.rda')
mw <- 14
movingaverages <- movaver(dat$Freq + 0.5, mw)
date <- as.Date(dat$Day, "%m/%d/%y")
year <- year(date)
month <- month(date)
sta2017 <- min(which(year == 2017))
end2017 <- max(which(year == 2017))
sta2018 <- min(which(year == 2018))
end2018 <- max(which(year == 2018))
sta2019 <- min(which(year == 2019))
end2019 <- max(which(year == 2019))
sta2017July <- min(which(((year == 2017) * (month == 7)) == 1))
sta2018July <- min(which(((year == 2018) * (month == 7)) == 1))
sta2019July <- min(which(((year == 2019) * (month == 7)) == 1))
movingaverages0 <- movingaverages[sta2017:end2019]
MedianPhi <- rep(NA, 5)
for (i in 1:5) {
MedianPhi[i] <- median(mo0$Phi[i, ])
}
MedianMu <- rep(median(mo0$muq), 1095)
Mediansigma2 <- median(mo0$sigma2)
cc1 <- GibbsRFLSM.simmax.residual(movingaverages0, mo0$Phi,
matrix(mo0$muq, nrow = 1095, ncol = 1000, byrow = T),
mo0$sigma2,
MedianPhi,
MedianMu,
Mediansigma2,
nsim = 1000)
cc2 <- GibbsRFLSM.simmax.Yao(movingaverages0, mo0$Phi,
matrix(mo0$muq, nrow = 1095, ncol = 1000, byrow = T),
mo0$sigma2,
nsim = 1000)
GibbsRFLSM.PPP.Yao <- function(Y, Phi, Mu, sigma2, FAP0 = 0.2,
nsim = 1000) {
q <- dim(Phi)[1]
n <- length(Y) - q
ccrep <- GibbsRFLSM.simmax.Yao(Y, Phi, Mu, sigma2,
nsim)
tmpYao <- (Y[-c(1:5)] - mean(Y[-c(1:5)])) ^ 2 / var(Y[-c(1:5)])
tmpOmni <- mean(ccrep > max(tmpYao))
tmpInd <- rep(NA, n)
for (i in 1:n) {
tmpInd[i] <- mean(ccrep > tmpYao[i])
}
list("Omni" = tmpOmni, "Ind" = tmpInd)
}
GibbsRFLSM.PPP.Yao(movingaverages0, mo0$Phi, matrix(mo0$muq, nrow = 1095, ncol = 1000, byrow = T), mo0$sigma2, 1000)
GibbsRFLSM.PPP.residual <- function(Y, Phi, Mu, sigma2,
Phihat, Muhat, sigma2hat,
nsim = 1000) {
q <- dim(Phi)[1]
n <- length(Y) - q
ccrep <- GibbsRFLSM.simmax.residual(Y, Phi, Mu, sigma2,
Phihat, Muhat, sigma2hat,
nsim)
tmp <- Y - Muhat
tmpV <- getV(tmp, q)
tmp <- tmp[-c(1:q)]
tmpV <- tmpV[-c(1:q), ]
tmpresi <- (tmp - tmpV %*% Phihat) ^ 2 / sigma2hat
tmpOmni <- mean(ccrep > max(tmpresi))
tmpInd <- rep(NA, n)
for (i in 1:n) {
tmpInd[i] <- mean(ccrep > tmpresi[i])
}
list("Omni" = tmpOmni, "Ind" = tmpInd)
}
GibbsRFLSM.PPP.residual(movingaverages0, mo0$Phi,
matrix(mo0$muq, nrow = 1095, ncol = 1000, byrow = T),
mo0$sigma2,
MedianPhi,
MedianMu,
Mediansigma2,
nsim = 1000)
roxygen2::roxygenise()
GibbsRFLSM.PPP.residual <- function(Y, Phi, muq, sigma2,
Phihat, muqhat, sigma2hat,
nsim = 1000) {
q <- dim(Phi)[1]
n <- length(Y)
m <- dim(Phi)[2]
Muq <- matrix(muq, nrow = n, ncol = m, byrow = T)
Muqhat <- rep(muqhat, n)
ccrep <- GibbsRFLSM.simmax.residual(Y, Phi, Muq, sigma2,
Phihat, Muqhat, sigma2hat,
nsim)
tmp <- Y - muqhat
tmpV <- getV(tmp, q)
tmp <- tmp[-c(1:q)]
tmpV <- tmpV[-c(1:q), ]
tmpresi <- (tmp - tmpV %*% Phihat) ^ 2 / sigma2hat
tmpOmni <- mean(ccrep > max(tmpresi))
tmpInd <- rep(NA, n - q)
for (i in 1:(n - q)) {
tmpInd[i] <- mean(ccrep > tmpresi[i])
}
list("Omni" = tmpOmni, "Ind" = tmpInd)
}
GibbsRFLSM.PPP.residual(movingaverages0, mo0$Phi,
mo0$muq, mo0$sigma2,
MedianPhi,
median(mo0$muq),
Mediansigma2,
nsim = 1000)
roxygen2::roxygenise()
aa <- GibbsRFLSM.PPP.residual(movingaverages0, mo0$Phi,
mo0$muq, mo0$sigma2,
MedianPhi,
median(mo0$muq),
Mediansigma2,
nsim = 1000)
which(aa$Ind <= 0.2)
out <- rep(NA, 1090)
for ( i in seq(1090)) {
out[i] <- 1 - mean(cc1 > tmpresi[i])
}
cc1 <- GibbsRFLSM.simmax.residual(movingaverages0, mo0$Phi,
matrix(mo0$muq, nrow = 1095, ncol = 1000, byrow = T),
mo0$sigma2,
MedianPhi,
MedianMu,
Mediansigma2,
nsim = 1000)
shift1 <- which(tmpresi > quantile(cc1, 0.8))
tmp <- movingaverages0 - MedianMu
tmpV <- getV(tmp, 5)
tmp <- tmp[-c(1:5)]
tmpV <- tmpV[-c(1:5), ]
tmpresi <- (tmp - tmpV %*% MedianPhi) ^ 2 / Mediansigma2
shift1 <- which(tmpresi > quantile(cc1, 0.8))
shift1
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::install_github("bolus123/BayesianLassoMonitoring")
remove.packages("BayesianLassoMonitoring")
