Rcpp::compileAttributes()
Rcpp::sourceCpp("src/source.cpp")
View(getPosteriorH0)
View(BenjaminiHochberg)
View(getPosterior)
devtools::check()
?install.packages
install.packages("C:/Users/Yuhui/OneDrive/Documents/GitHub/BayesianLassoMonitoring_1.0.tar.gz", repos = NULL, type="source")
library(BayesianLassoMonitoring)
Y <- arima.sim(list(ar = 0.5), n = 100)
Y
V <- getV(Y, 5)
V
Y <- arima.sim(list(ar = 0.5), n = 100)
V <- getV(Y, 5)
GS <- GradualShift(100)
IS <- IsolatedShift(100)
SS <- SustainedShift(100)
SS
X <- cbind(IS, SS)
X
library(glmnet)
q <- 5
lambda2 <- 5
T <- 100
#######################################
Y <- arima.sim(list(ar = 0.5), n = T)
V <- getV(Y, q)
GS <- GradualShift(T)
IS <- IsolatedShift(T)
SS <- SustainedShift(T)
X <- cbind(IS, SS)
?glmnet
initM0 <- glmnet(cbind(Y, X), Y, lambda = sqrt(lambda2))
initM0
initM0$a0
as.numeric(initM0$a0)
initM0$beta
beta1 <- as.numeric(initM0$beta[1:q])
beta1
dim(cbind(IS, SS))
initM0 <- glmnet(cbind(V, X), Y, lambda = sqrt(lambda2))
beta0 <- as.numeric(initM0$a0)
beta1 <- as.numeric(initM0$beta[1:q])
beta2 <- as.numeric(initM0$beta[(q + 1):()])
initM0 <- glmnet(cbind(V, X), Y, lambda = sqrt(lambda2))
beta0 <- as.numeric(initM0$a0)
beta1 <- as.numeric(initM0$beta[1:q])
dim(cbind(V, IS, SS))
5 + T + T - 2
beta0 <- as.numeric(initM0$a0)
beta1 <- as.numeric(initM0$beta[1:q])
beta2 <- as.numeric(initM0$beta[(q + 1):(q + T + T - 2)])
beta1
beta2
beta0
M1 <- getPosterior(Y, V, X, lambda2, beta0, beta1, beta2, 100, 1000)
M1
M1$beta
dim(M1$beta)
library(glmnet)
library(BayesianLassoMonitoring)
q <- 5
lambda2 <- 5
T <- 100
seed <- 12345
#######################################
set.seed(seed)
# get a simulated process
Y <- arima.sim(list(ar = 0.5), n = T)
# get lagged variables
V <- getV(Y, q)
# get shifts
IS <- IsolatedShift(T)
SS <- SustainedShift(T)
X <- cbind(IS, SS)
#######################################
# initialize the MCMC process using the LASSO model
initM0 <- glmnet(cbind(V, X), Y, lambda = sqrt(lambda2))
beta0 <- as.numeric(initM0$a0)
beta1 <- as.numeric(initM0$beta[1:q])
beta2 <- as.numeric(initM0$beta[(q + 1):(q + T + T - 2)])
#######################################
# get the bayesian model
M1 <- getPosterior(Y, V, X, lambda2, beta0, beta1, beta2, 100, 1000)
dim(beta2)
dim(M1$beta)
(q + T + T - 2)
beta2 <- M1$beta[, (q + 1 + 1):(q + 1 + T + T - 2)]]
beta2 <- M1$beta[, (q + 1 + 1):(q + 1 + T + T - 2)]
beta2
BH <- BenjaminiHochberg(FDR = 0.2, beta2 = beta2, side = "two-sided")
BH
M1$lambda2
M1$sigma2
