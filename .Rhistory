points(6:183, xx$Y.tr[, 2], col = 'red')
points(6:183, xx$Y.tr[, 3], col = 'red')
points(6:183, xx$Y.tr[, 4], col = 'red')
points(6:183, xx$Y.tr[, 5], col = 'red')
bb
bb$Y.tr[, 1]
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
bb <- GibbsRFLSM.sim.ph1(10000, result$Y1$Y, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa,
NULL, result$Gamma, result$Tau)
bb$Y.tr[, 1]
bb$Y.tr[, 2]
bb$Y.tr[, 3]
bb$Y.tr[, 4]
bb$Y.tr[, 5]
bb$Y.tr[, 6]
bb1 <- BayesianLASSOMonitoring::backtrans(bb$Y.tr, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
bb1
bb1[, 1]
bb1[, 2]
bb1[, 3]
bb1
bb1[, 1]
cc1 <- BayesianLASSOMonitoring::backtrans(result$Y1$Y, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
cc1
plot(cc1)
points(bb1[, 1])
points(bb1[, 1], col = 'red')
points(bb1[, 2], col = 'red')
ff <- residual.stat(result$Y1$Y, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat)
ff
bb1
bb1[, 1]
cc1
cc1[, 1]
cc1
Phihat
debug(residual.stat)
ff <- residual.stat(result$Y1$Y, Phihat, muqhat, sigma2hat,
X, Betahat, Kappahat)
Muhat
Y.tr
Y.tr - Muhat
fit
(V[i] - fit[i - q])
tmp
xx
bb1
result$Y1$Y
plot(result$Y1$Y)
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
points(bb$Y.tr[, 6], col = 'red')
plot(result$Y1$Y)
points(bb$Y.tr[, 1], col = 'red')
points(bb$Y.tr[, 2], col = 'red')
points(bb$Y.tr[, 3], col = 'red')
points(bb$Y.tr[, 4], col = 'red')
points(bb$Y.tr[, 5], col = 'red')
points(bb$Y.tr[, 6], col = 'red')
points(bb$Y.tr[, 7], col = 'red')
points(bb$Y.tr[, 8], col = 'red')
points(bb$Y.tr[, 9], col = 'red')
points(bb$Y.tr[, 10], col = 'red')
points(cc$Y.tr[, 5], col = 'blue')
points(cc$Y.tr[, 1], col = 'blue')
points(cc$Y.tr[, 2], col = 'blue')
points(cc$Y.tr[, 3], col = 'blue')
points(cc$Y.tr[, 4], col = 'blue')
points(cc$Y.tr[, 5], col = 'blue')
points(cc$Y.tr[, 6], col = 'blue')
points(cc$Y.tr[, 7], col = 'blue')
points(cc$Y.tr[, 8], col = 'blue')
points(cc$Y.tr[, 9], col = 'blue')
points(cc$Y.tr[, 10], col = 'blue')
cc$Y.tr[1, ]
dim(cc$Y.tr[1, ])
dim(cc$Y.tr)
quantile(cc$Y.tr[1, ], c(0.025, 0.975))
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.tr)[2]
TT <- dim(Y.tr)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
debug(adjalp)
adjalp(bb$Y.tr)
debug(root.finding)
tmplower
tmpupper
tmplower
tmpupper
(tmplower <= Y.sim[, i])
(tmplower <= Y.sim[, i]) && (Y.sim[, i] <= tmpupper)
(tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT)
}
adjalp(bb$Y.tr)
?uniroot
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4)) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 0.001) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)
}
adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adjalp(bb$Y.tr)
bb$Y.tr
adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr, c(0.001899412, 1-0.001899412))
}
aa
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(0.001899412, 1-0.001899412))
}
aa
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
bb <- GibbsRFLSM.sim.ph1(10000, result$Y1$Y, result$Phi, result$muq, result$sigma2,
X, result$Beta, result$Kappa,
NULL, result$Gamma, result$Tau)
adja <- adjalp(bb$Y.tr)
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(aa[, 1], type = 'l')
points(aa[, 2], type = 'l')
dim(result$Y1)
dim(result$Y1$Y)
length(result$Y1$Y)
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
cc1 <- BayesianLASSOMonitoring::backtrans(result$Y1$Y, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
bb1 <- BayesianLASSOMonitoring::backtrans(bb$Y.tr, const = 10, meanY = result$Y1$meanY, sdY = result$Y1$sdY)
adja <- adjalp(bb1)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb1[i, ], c(adja, 1-adja))
}
plot(cc1)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
aa[, 1]
cc1
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
#' obtain the residual statistics
#'
#' @param Y.sim is the transformed vector
#' @param FAP0 is the matrix of laggy coefficients
#' @param interval is the interval
#' @param tol is the tolerance
#' @export
#'
adjalp <- function(Y.sim, FAP0 = 0.3, side = "two-sided", interval = c(0.00001, 0.4), tol = 1e-6) {
root.finding <- function(adjalp, FAP0, Y.sim, nsim, TT, side) {
tmplower <- rep(NA, TT)
tmpupper <- rep(NA, TT)
for (i in 1:TT) {
if (side == "two-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp / 2)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp / 2)
} else if (side == "right-sided") {
tmplower[i] <- -Inf #quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- quantile(Y.sim[i, ], 1 - adjalp)
} else if (side == "left-sided") {
tmplower[i] <- quantile(Y.sim[i, ], adjalp)
tmpupper[i] <- Inf #quantile(Y.sim[i, ], 1 - adjalp)
}
}
tmp <- rep(NA, TT)
for (i in 1:nsim) {
tmp[i] <- sum((tmplower <= Y.sim[, i]) & (Y.sim[, i] <= tmpupper)) == TT
}
tmpFAP0 <- 1 - mean(tmp)
d <- FAP0 - tmpFAP0
#cat("adjalp:", adjalp, ", tmpFAP0:", tmpFAP0, "and d:", d, "\n")
d
}
nsim <- dim(Y.sim)[2]
TT <- dim(Y.sim)[1]
uniroot(root.finding, interval, FAP0 = FAP0, Y.sim = Y.sim, nsim = nsim, TT = TT,
side = side, tol = tol)$root
}
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja, 1-adja))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
adja
adja <- adjalp(bb$Y.tr)
aa <- matrix(NA, nrow = 178, ncol = 2)
for (i in 1:178) {
aa[i, ] <- quantile(bb$Y.tr[i, ], c(adja / 2, 1-adja / 2))
}
plot(result$Y1$Y)
points(6:183, aa[, 1], type = 'l')
points(6:183, aa[, 2], type = 'l')
(aa[, 1] <= result$Y1$Y) & (result$Y1$Y <= aa[, 2])
result$Y1$Y <= aa[, 2]
result$Y1$Y
aa[, 2]
result$Y1$Y <= aa[, 2]
(aa[, 1] <= result$Y1$Y[6:183]) & (result$Y1$Y[6:183] <= aa[, 2])
Rcpp::compileAttributes()
Rcpp::compileAttributes()
Rcpp::compileAttributes()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
debug(Ph1BayesianLASSO)
library(BayesianLASSOMonitoring)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(
Y, H = H, X = cbind(X1, X2), q = q,
nsim = nsim, burnin = burnin
)
Y
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
model$meanY
model$sdY
backtrans(Y.tr.sim, log, const, sta, model$meanY,
model$sdY)
debug(backtrans)
backtrans(Y.tr.sim, log, const, sta, model$meanY,
model$sdY)
sdY
out
ut * sdY
out * sdY
sdY
out
Y
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring")
set.seed(1234)
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
TT <- 183
w <- 7
q <- 5
Y0 <- BayesianLASSOMonitoring::rzinpoisinar3(TT + w - 1, alpha, lambda, pi, ceiling(TT / 2) + w - 1, delta = 2, burnin = 100)
Y0 <- Y0
Y <- Y0[(TT + w - 1 - TT + 1):(TT + w - 1)]
Y0 <- Y0[1:(w - 1)]
H <- BayesianLASSOMonitoring::getHMatMT(TT, q)
H1 <- matrix(1, nrow = 1000, ncol = TT - q)
X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT + 1000, 3.5, 3)
X1 <- X[(TT + 1):(1000 + TT), ]
X <- X[1:TT, ]
debug(Ph1BayesianLASSO)
library(BayesianLASSOMonitoring)
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
dim(Y.tr.sim)
adja.ma
adja.tr
lim.tr
debug(Ph1BayesianLASSO)
result <- Ph1BayesianLASSO(Y, w, H, X, Y0 = Y0[1:(w - 1)], const = 10, nsim.chart = 10000)
TT
dim(Y.tr.sim)
dim(lim.tr)
remove.packages("BayesianLASSOMonitoring")
