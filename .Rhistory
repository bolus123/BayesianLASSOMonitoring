out <- list(
beta1 = beta1Samples[select, ],
beta2 = beta2Samples[select, ],
#invTau21 = invTau21Samples[select, ],
#invTau22 = invTau22Samples[select, ],
sigma2 = sigma2Samples[select],
lambda = lambdaSamples[select]
)
return(out)
}
getSim(1, pars, 5, 12345)
Q
?BenjaminiHochberg
getSim <- function(X, pars, q, seed, nsamp = 1000, burnin = 50, step = 1) {
set.seed(seed + X)
fap0 <- pars[X, 1]
n <- pars[X, 2]
phi <- pars[X, 3]
delta <- pars[X, 4]
############################
Y <- arima.sim(list(ar = phi), n = n)
Y[(round(n/2) + 1):n] <- Y[(round(n/2) + 1):n] + delta * sqrt(1 / (1 - phi ^ 2))
############################
intercept <- mean(Y)
Y1 <- Y - intercept
############################
V <- getV(Y1, q)
Y1 <- Y1[-c(1:q)]
V <- V[-c(1:q), ]
IS <- IsolatedShift(n - q)
SS <- SustainedShift(n - q)
X <- cbind(IS, SS)
aa1 <- gibbsBLasso(Y1, V, X,
lambda = NULL,
r = 1,
delta = 0.1,
nsamp = nsamp,
burnin = burnin,
step = step)
bb1 <- getPvalue(aa1$beta2, "two-sided")
cc1 <- BenjaminiHochberg(fap0, aa1$beta2, "two-sided",
1, 0.0001)
dd1 <- BonferroniCorrection(fap0, aa1$beta2, "two-sided",
1, 0.0001)
}
seed <- 12345
q <- 5
fap0vec <- c(0.2)
phiVec <- c(0.5)
tVec <- c(100, 200, 300)
deltaVec <- c(0)
pars <- expand.grid(fap0vec, tVec, phiVec, deltaVec)
getSim(1, pars, 5, 12345)
debug(getsim)
debug(getSim)
seed <- 12345
q <- 5
fap0vec <- c(0.2)
phiVec <- c(0.5)
tVec <- c(100, 200, 300)
deltaVec <- c(0)
pars <- expand.grid(fap0vec, tVec, phiVec, deltaVec)
getSim(1, pars, 5, 12345)
cc1 <- BenjaminiHochberg(fap0, aa1$beta2, "two-sided",
1, 0.0001)
cc1
dd1 <- BonferroniCorrection(fap0, aa1$beta2, "two-sided",
1, 0.0001)
dd1
getSim <- function(X, pars, q, seed, nsamp = 1000, burnin = 50, step = 1) {
set.seed(seed + X)
fap0 <- pars[X, 1]
n <- pars[X, 2]
phi <- pars[X, 3]
delta <- pars[X, 4]
############################
Y <- arima.sim(list(ar = phi), n = n)
Y[(round(n/2) + 1):n] <- Y[(round(n/2) + 1):n] + delta * sqrt(1 / (1 - phi ^ 2))
############################
intercept <- mean(Y)
Y1 <- Y - intercept
############################
V <- getV(Y1, q)
Y1 <- Y1[-c(1:q)]
V <- V[-c(1:q), ]
IS <- IsolatedShift(n - q)
SS <- SustainedShift(n - q)
X <- cbind(IS, SS)
aa1 <- gibbsBLasso(Y1, V, X,
lambda = NULL,
r = 1,
delta = 0.1,
nsamp = nsamp,
burnin = burnin,
step = step)
#bb1 <- getPvalue(aa1$beta2, "two-sided")
cc1 <- BenjaminiHochberg(fap0, aa1$beta2, "two-sided",
1, 0.0001)
dd1 <- BonferroniCorrection(fap0, aa1$beta2, "two-sided",
1, 0.0001)
############################
c(sum(cc1[, 4]) == 0, sum(dd1[, 4]) == 0)
}
getSim(1, pars, 5, 12345)
cl <- parallel::makeCluster(2)
parallel::clusterEvalQ(cl, require(VGAM))
parallel::clusterEvalQ(cl, require(mvtnorm))
parallel::clusterEvalQ(cl, require(truncnorm))
parallel::clusterEvalQ(cl, require(pracma))
parallel::clusterEvalQ(cl, require(BayesianLassoMonitoring))
parallel::clusterEvalQ(cl, require(VGAM))
parallel::clusterEvalQ(cl, require(mvtnorm))
parallel::clusterEvalQ(cl, require(truncnorm))
parallel::clusterEvalQ(cl, require(pracma))
parallel::clusterEvalQ(cl, require(BayesianLassoMonitoring))
parallel::clusterExport(cl, c("rmvnormMono", "gibbsBLasso", "getSim"))
# library(pscl) # rigamma
#library(mnormt) # rmnorm
library(VGAM) # rinv.gaussian
#library(miscTools) # colMeans
library(mvtnorm)
library(truncnorm)
library(pracma)
library(BayesianLassoMonitoring)
library(parallel)
#getV <- function(Y, q) {
#  n <- length(Y)
#  out <- matrix(0, nrow = n, ncol = q)
#  for (i in 2:n) {
#    if (i <= q) {
#      out[i, 1:(i - 1)] <- Y[(i -1):1]
#    } else {
#      out[i, ] <- Y[(i - 1):(i - q)]
#    }
#  }
#  out
#}
#
#IsolatedShift <- function(n) {
#  eye(n)
#}
#
#SustainedShift <- function(n) {
#  out <- matrix(1, n, n)
#  out <- tril(out)
#  out[, c(-1, -n)]
#}
rmvnormMono <- function(mean, varcov) {
m <- length(mean)
out <- rep(0, m)
for (i in 1:m) {
if (i > 1) {
tmpinv <- solve(varcov[1:(i-1), 1:(i-1)])
tmpvarcov <- varcov[1:(i-1), i]
mu <- mean[i] + tmpvarcov %*% tmpinv %*% (out[1:(i-1)] - mean[1:(i-1)])
sigma <- sqrt(varcov[i, i] - tmpvarcov %*% tmpinv %*% tmpvarcov)
out[i] <- rtruncnorm(1, a = - abs(out[i - 1]), b = abs(out[i - 1]), mean = mu, sd = sigma)
} else {
mu <- mean[i]
sigma <- sqrt(varcov[i, i])
out[i] <- rnorm(1, mu, sigma)
}
}
return(out)
}
gibbsBLasso <- function(Y, V, X,
lambda = NULL,
updateLambda = TRUE,
r = 1,
delta = 0.1,
nsamp = 1000,
burnin = 100,
step = 5#,
#max.steps = 100000,
#intercept = TRUE
) {
n <- length(Y)
q <- ncol(V)
p <- ncol(X)
m <- p + q
#if (intercept == TRUE) {
#  intercept <- mean(Y)
#  Y <- Y - intercept
#} else {
#  intercept <- 0
#}
XtX <- t(X) %*% X
VtV <- t(V) %*% V
VX <- cbind(V, X)
VXtVX <- t(VX) %*% VX
VXY <- t(VX) %*% Y
beta <- drop(backsolve(VXtVX + diag(nrow=m), VXY))
beta1 <- beta[1:q]
beta2 <- beta[(q + 1):m]
residue <- drop(Y - VX %*% beta)
sigma2 <- drop((t(residue) %*% residue) / n)
invTau2 <- 1 / (beta * beta)
invTau21 <- invTau2[1:q]
invTau22 <- invTau2[(q + 1):m]
if (is.null(lambda)) {
lambda <- m * sqrt(sigma2) / sum(abs(beta))
}
totSim <- burnin + nsamp * step
beta1Samples <- matrix(0, totSim, q)
beta2Samples <- matrix(0, totSim, p)
sigma2Samples <- rep(0, totSim)
invTau21Samples <- matrix(0, totSim, q)
invTau22Samples <- matrix(0, totSim, p)
lambdaSamples <- rep(0, totSim)
k <- 0
while (k < totSim) {
k <- k + 1
#if (k %% 100 == 0) {
#  cat('Iteration:', k, "\r")
#}
# sample beta1
Ytilda <- drop(Y - X %*% beta2)
VY <- t(V) %*% Ytilda
invD1 <- diag(invTau21)
invA1 <- solve(VtV + invD1)
mean1 <- invA1 %*% VY
varcov1 <- sigma2 * invA1
#beta <- drop(rmnorm(1, mean, varcov))
#beta2 <- drop(rmvnorm(1, mean2, varcov2)) # this one needs to be constrainted
beta1 <- rmvnormMono(mean1, varcov1)
beta1Samples[k,] <- beta1
# sample beta2
Ytilda <- drop(Y - V %*% beta1)
XY <- t(X) %*% Ytilda
invD2 <- diag(invTau22)
invA2 <- solve(XtX + invD2)
mean2 <- invA2 %*% XY
varcov2 <- sigma2 * invA2
#beta <- drop(rmnorm(1, mean, varcov))
beta2 <- drop(rmvnorm(1, mean2, varcov2, checkSymmetry = FALSE))
beta2Samples[k,] <- beta2
beta <- c(beta1, beta2)
# sample sigma2
shape <- (n+m-1)/2
residue <- drop(Y - VX %*% beta)
scale <- (t(residue) %*% residue + t(beta) %*% diag(c(invTau2)) %*% beta)/2
sigma2 <- 1/rgamma(1, shape, 1/scale)
sigma2Samples[k] <- sigma2
# sample tau2
muPrime <- sqrt(lambda^2 * sigma2 / beta^2)
lambdaPrime <- lambda^2
invTau2 <- rep(0, m)
for (i in seq(m)) {
invTau2[i] <- rinv.gaussian(1, muPrime[i], lambdaPrime)
}
invTau21 <- invTau2[1:q]
invTau22 <- invTau2[(q + 1):m]
invTau21Samples[k, ] <- invTau21
invTau22Samples[k, ] <- invTau22
# update lambda
if (updateLambda == TRUE) {
shape = r + m/2
scale = delta + sum(1/invTau2)/2
lambda <- rgamma(1, shape, 1/scale)
}
# if (k %% 10 == 0) {
# low <- k - 9
# high <- k
# lambda <- sqrt( 2*m / sum(colMeans(invTau2Samples[low:high, ])) )
# }
lambdaSamples[k] <- lambda
}
#colMedians(betaSamples[seq(max.steps/2, max.steps, 5), ])
select <- seq(burnin + 1, totSim, step)
out <- list(
beta1 = beta1Samples[select, ],
beta2 = beta2Samples[select, ],
#invTau21 = invTau21Samples[select, ],
#invTau22 = invTau22Samples[select, ],
sigma2 = sigma2Samples[select],
lambda = lambdaSamples[select]
)
return(out)
}
######################################
getSim <- function(X, pars, q, seed, nsamp = 1000, burnin = 50, step = 1) {
set.seed(seed + X)
fap0 <- pars[X, 1]
n <- pars[X, 2]
phi <- pars[X, 3]
delta <- pars[X, 4]
############################
Y <- arima.sim(list(ar = phi), n = n)
Y[(round(n/2) + 1):n] <- Y[(round(n/2) + 1):n] + delta * sqrt(1 / (1 - phi ^ 2))
############################
intercept <- mean(Y)
Y1 <- Y - intercept
############################
V <- getV(Y1, q)
Y1 <- Y1[-c(1:q)]
V <- V[-c(1:q), ]
IS <- IsolatedShift(n - q)
SS <- SustainedShift(n - q)
X <- cbind(IS, SS)
aa1 <- gibbsBLasso(Y1, V, X,
lambda = NULL,
r = 1,
delta = 0.1,
nsamp = nsamp,
burnin = burnin,
step = step)
#bb1 <- getPvalue(aa1$beta2, "two-sided")
cc1 <- BenjaminiHochberg(fap0, aa1$beta2, "two-sided",
1, 0.0001)
dd1 <- BonferroniCorrection(fap0, aa1$beta2, "two-sided",
1, 0.0001)
############################
c(sum(cc1[, 4]) == 0, sum(dd1[, 4]) == 0)
}
######################################
seed <- 12345
q <- 5
fap0vec <- c(0.2)
phiVec <- c(0.5)
#tVec <- c(100, 200, 300)
tVec <- c(100)
deltaVec <- c(0, 0.1)
pars <- expand.grid(fap0vec, tVec, phiVec, deltaVec)
######################################
cl <- parallel::makeCluster(2)
parallel::clusterEvalQ(cl, require(VGAM))
parallel::clusterEvalQ(cl, require(mvtnorm))
parallel::clusterEvalQ(cl, require(truncnorm))
parallel::clusterEvalQ(cl, require(pracma))
parallel::clusterEvalQ(cl, require(BayesianLassoMonitoring))
parallel::clusterExport(cl, c("rmvnormMono", "gibbsBLasso", "getSim"))
parallel::parLapplyLB(cl = cl, X = 1:2, fun = getSim, pars = pars, q = q,
seed = seed, nsamp = 1000, burnin = 50, step = 1)
Rcpp::compileAttributes()
vignette("Rcpp-attributes")
install.packages("roxygen2")
library(roxygen2)
roxygenize()
roxygenize()
?arima.sim
roxygen2()
roxygenize()
roxygenize()
vignette("rd")
vignette("rd-other")
?roxygen2
?forecast
library(forec)
library(forecast)
install.packages(forecast)
install.packages("forecast")
?forecast
library(forecast)
?forecast
roxygen2::roxygenise()
roxygen2::roxygenise()
#' Package BayesianLASSOMonitoring
#'
#' Package description.
#'
#' @name BayesianLASSOMonitoring-package
#' @import Rcpp
#' @useDynLib BayesianLASSOMonitoring, .registration = TRUE
NULL
roxygen2::roxygenise()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
?density
?dnorm
roxygen2::roxygenise()
roxygen2::roxygenise()
Rcpp::compileAttributes()
install.packages('devtools')
devtools::install_github("bolus123/BayesianLassoMonitoring")
roxygen2::roxygenise()
Rcpp.package.skeleton()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
result <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, "MonoALASSO",
Inf, 0, 1000, 1, 1, 1e-10, H)
result
result$Phi[, 50]
result$Phi[, 51]
result$Phi[, 52]
result$Phi[, 53]
result$Phi[, 54]
result$Phi[, 55]
result$sigma2[, 50]
result$sigma2[, 51]
result$Phi[, 56]
result$Phi[, 57]
result$Phi[, 58]
result$sigma2[, 55]
result$sigma2[, 56]
result$sigma2[, 57]
result$sigma2[, 58]
result$Tau[, 56]
result$Tau[, 55]
result$Tau[, 57]
result$Gamma[, 57]
result$Gamma[, 57]
result$Gamma[, 59]
result$Gamma[, 58]
result$Gamma[, 56]
result$muq[, 56]
result$muq[, 57]
result$Mu[, 57]
result$Mu[, 56]
result$pho[, 56]
result$pho[, 57]
result$lambda2[, 57]
result$lambda2[, 56]
result$lambda2[, 55]
result$lambda2[, 54]
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
result <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, "MonoALASSO",
Inf, 0, 60, 1, 1, 1e-10, H)
result
result$eta2
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
result <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, "MonoALASSO",
Inf, 0, 60, 1, 1, 1e-10, H)
result
?VGAM
install.packages("VGRAM")
install.packages("VGAM")
VGAM::rinv.gaussian()
?VGAM::rinv.gaussian
VGAM::rinv.gaussian(1, 1, 1)
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
result <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, "MonoALASSO",
Inf, 0, 60, 1, 1, 1e-10, H)
result
Rcpp::compileAttributes()
roxygen2::roxygenise()
install.packages("roxygen2")
install.packages("roxygen2")
install.packages("roxygen2")
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
?arima
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
Rcpp::compileAttributes()
library(BayesianLassoMonitoring)
set.seed(12345)
n <- 365
Y <- arima.sim(list(ar = 0.5), n = n)
H <- cbind(getHMatSustained(n, 5, 1), getHMatIsolated(n, 5, 1))
result <- GibbsRFLSM(Y, 5, diag(nrow = 5), 0.1, 0.1, 0.1, 0.1, 1, 1, 0.1, "MonoALASSO",
Inf, 0, 100, 1, 100, 1e-10, H)
result
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
roxygen2::roxygenise()
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::sourceCpp("src/BayesianLASSOMonitoring.cpp")
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
