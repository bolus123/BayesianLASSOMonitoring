ph1mat <- matrix(NA, nrow = n - q, ncol = nnsim)
for (i in 1:nnsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side)
}
debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nnsim)
for (i in 1:nnsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side)
}
debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
debug(root.finding)
nsin
nsim
dim(ph1mat)
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side)
}
debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side)$root
}
##debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
}
##debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
adj.alpha <- uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n, ncol = 2)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
list("lim" = lim, "adj.alpha" = adj.alpha)
}
##debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
adj.alpha <- uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n, ncol = 2)
for (i in 1:(n - q)) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
list("lim" = lim, "adj.alpha" = adj.alpha)
}
##debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
adj.alpha <- uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n - q, ncol = 2)
for (i in 1:(n - q)) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
list("lim" = lim, "adj.alpha" = adj.alpha)
}
##debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
Y1
plot(Y1[-c(1:q)])
points(lim[, 1])
points(ww$lim[, 1])
points(ww$lim[, 2])
ee$Y
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
adj.alpha <- uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n - q, ncol = 2)
sig <- matrix(NA, nrow = n - q, ncol = 1)
for (i in 1:(n - q)) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
sig <- 1 - ((lim[, 1] <= model$Y) & (model$Y <= lim[, 2]))
list("grandsig" = sum(sig) > 0, "sig" = sig, "lim" = lim, "adj.alpha" = adj.alpha)
}
ww <- Ph1MultipleTesting.Y0tr(ee)
debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
adj.alpha
lim
model$Y
Ph1MultipleTesting.Y0tr <- function(model, nsim = 10000, FAP0 = 0.2, side = "right-sided") {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] <= ph1mat[, i]) & (ph1mat[, i] <= lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$muq[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Kappa[, tmpsel])
}
ph1mat[, i] <- simYph1(matrix(model$Yyj[, tmpsel]), matrix(model$Phi[, tmpsel]), matrix(Mu0),
matrix(model$sigma2[tmpsel]), matrix(model$theta[tmpsel]), 1e-32)
}
adj.alpha <- uniroot(root.finding, c(0.000001, 0.499999), ph1mat = ph1mat, FAP0 = FAP0, n = n - q, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n - q, ncol = 2)
sig <- matrix(NA, nrow = n - q, ncol = 1)
for (i in 1:(n - q)) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
sig <- 1 - ((lim[, 1] <= model$Y[-c(1:q)]) & (model$Y[-c(1:q)] <= lim[, 2]))
list("grandsig" = sum(sig) > 0, "sig" = sig, "lim" = lim, "adj.alpha" = adj.alpha)
}
#debug(Ph1MultipleTesting.Y0tr)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
X<-11
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
ee <- BayesianLASSOMonitoring::GibbsRFLSMYJZ(Y1, H1)
ww <- Ph1MultipleTesting.Y0tr(ee)
ww
ee$Y
plot(ee$Y)
points(ww$lim[, 2], type = 'l')
roxygen2::roxygenise()
