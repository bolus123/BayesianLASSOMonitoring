BayesianLASSOMonitoring::simYyjph1(as.matrix(Yyj), aa$Phi[, 1],  aa$Mu[, 1],  aa$sigma2[1])
aa$Phi[, 1]
matrix(aa$Phi[, 1])
BayesianLASSOMonitoring::simYyjph1(matrix(Yyj), matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
debug(BayesianLASSOMonitoring::simYyjph1)
BayesianLASSOMonitoring::simYyjph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
BayesianLASSOMonitoring::simYXyjph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  matrix(aa$Mu[, 1]),  aa$sigma2[1])
simYyjXph1
matrix(aa$Mu[, 1])
aa$Mu
Mu <- aa$H %*% (aa$Gamma[, 1] * aa$Tau[, 1]) + aa$X %*% aa$Beta[, 1] + aa$mu0[1]
Mu
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
ee <- BayesianLASSOMonitoring::simYyjXph1(Yyj, matrix(aa$Phi[, 1]),  Mu,  aa$sigma2[1])
plot(ee)
plot(ee)
points(Yyj, col = 'red')
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183, 365)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 8
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2, alpha, lambda, pi,
ceiling(TT1 * tt), delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(1, TT1 - q, 7)]
H1 <- H1[, -c(colSums(H1) < 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
##############################################
bset <- list(
"method" = "regression",
"phicons" = 1,
"phiq" = 5,
"phiA" = diag(nrow = 5),
"phibound0" = Inf,
"phiboundqplus1" = 0,
"betaA" = diag(nrow = 1),
"gammaxi2" = 0.1,
"tautheta1" = 1,
"tautheta2" = 1,
"sigma2a" = 1,
"sigma2b" = 1,
"updatelambda2" = 1,
"lambda2alpha" = 1,
"lambda2beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"lowerbound" = 0,
"rounding" = 1,
"lambda2" = NULL,
"theta" = NULL
)
qq <- BayesianLASSOMonitoring::GibbsRFLSMX(matrix(Y1, ncol = 1), bset, H = H1,
tol = 1e-10, nsim = 300, thin = 10, burnin = 1000, verbose = 1)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183, 365)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 8
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2, alpha, lambda, pi,
ceiling(TT1 * tt), delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(1, TT1 - q, 7)]
H1 <- H1[, -c(colSums(H1) < 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
##############################################
bset <- list(
"method" = "regression",
"phimono" = 1,
"phiq" = 5,
"phiA" = diag(nrow = 5),
"phibound0" = Inf,
"phiboundqplus1" = 0,
"betaA" = diag(nrow = 1),
"gammaxi2" = 0.1,
"tautheta1" = 1,
"tautheta2" = 1,
"sigma2a" = 1,
"sigma2b" = 1,
"updatelambda2" = 1,
"lambda2alpha" = 1,
"lambda2beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"lowerbound" = 0,
"rounding" = 1,
"lambda2" = NULL,
"theta" = NULL
)
qq <- BayesianLASSOMonitoring::GibbsRFLSMX(matrix(Y1, ncol = 1), bset, H = H1,
tol = 1e-10, nsim = 300, thin = 10, burnin = 1000, verbose = 1)
qq
qq$lambda2
qq$Z
qq$nsim
pp <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y01(qq, bset)
pp
pp$grandsig
pp$sig
183 * 0.8
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
###################################
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183, 365)
#TT1 <- c(92)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 8
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2, alpha, lambda, pi,
ceiling(TT1 * tt), delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H1 <- H1[, seq(1, TT1 - q, 7)]
#H1 <- H1[, -c(colSums(H1) < 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
##############################################
bset <- list(
"method" = "regression",
"phimono" = 1,
"phiq" = 5,
"phiA" = diag(nrow = 5),
"phibound0" = Inf,
"phiboundqplus1" = 0,
"betaA" = diag(nrow = 1),
"gammaxi2" = 0.1,
"tautheta1" = 1,
"tautheta2" = 1,
"sigma2a" = 1,
"sigma2b" = 1,
"updatelambda2" = 1,
"lambda2alpha" = 1,
"lambda2beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"lowerbound" = 0,
"rounding" = 1,
"lambda2" = NULL,
"theta" = NULL
)
qq <- BayesianLASSOMonitoring::GibbsRFLSMX(matrix(Y1, ncol = 1), bset, H = H1,
tol = 1e-10, nsim = 300, thin = 10, burnin = 1000, verbose = 1)
pp <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y01(qq, bset)
pp
pp$sig
pp$grandsig
pp$adj.alpha
183
0.2 ^ (1/183)
1 - 0.2 ^ (1/183)
pp$Yph1[, 1]
pp$Yph1[, 2]
pp$Yph1[, 3]
hist(pp$Yph1[1, ])
hist(pp$Yph1[2, ])
hist(pp$Yph1[3, ])
hist(pp$Yph1[4, ])
hist(pp$Yph1[143, ])
hist(pp$Yph1[145, ])
hist(pp$Yph1[146, ])
hist(pp$Yph1[172, ])
hist(pp$Yph1[173, ])
which(pp$sig = =1)
which(pp$sig ==1)
hist(pp$Yph1[172, ])
Y[172, ]
Y1[172, ]
Y1
Y1[172]
qq$Z + qq$Y
qq$Z
dim(qq$Z)
qq$Y
qq$Z + qq$Y
rep(qq$Y, 2)
matrix(rep(qq$Y, 2), 2)
matrix(rep(qq$Y, 2), ncol = 2)
qq$Z + matrix(rep(qq$Y, 300), ncol = 2)
qq$Z + matrix(rep(qq$Y, 300), ncol = 300)
dd <- qq$Z + matrix(rep(qq$Y, 300), ncol = 300)
dd
dd
hist(dd[1, ])
hist(dd[2, ])
hist(dd[3, ])
hist(dd[, 1])
hist(dd[, 2])
hist(dd[, 3])
hist(dd[, 4])
hist(dd[, 5])
hist(dd[, 6])
dd[, 7
]
dd[, 1]
dd[, 2]
dd[, 3]
max(dd[, 3])
max(dd[, 1])
max(dd[, 2])
max(dd[, 3])
max(dd[, 4])
max(dd[, 5])
max(dd[, 100])
max(dd[, 120])
max(dd[, 130])
max(dd[, 160])
plot(dd[, 1])
BayesianLASSOMonitoring::yeojohnsontr(dd[, 1], qq$theta[1], 1e-6)
plot(BayesianLASSOMonitoring::yeojohnsontr(dd[, 1], qq$theta[1], 1e-6))
hist(BayesianLASSOMonitoring::yeojohnsontr(dd[, 1], qq$theta[1], 1e-6))
hist(BayesianLASSOMonitoring::yeojohnsontr(dd[, 2], qq$theta[2], 1e-6))
hist(BayesianLASSOMonitoring::yeojohnsontr(dd[, 3], qq$theta[3], 1e-6))
hist(BayesianLASSOMonitoring::yeojohnsontr(dd[, 4], qq$theta[4], 1e-6))
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
pp
pp$grandsig
pp$sig
pp$lim
pp$grandsig
pp$adj.alpha
pp$Yph1
plot(Y)
plot(Y, type = 'l')
points(pp$lim[, 2], type = 'l', col = 'red')
pp$lim[, 2]
plot(Y1, type = 'l')
points(pp$lim[, 2], type = 'l', col = 'red')
qq$H %*% (qq$Gamma * qq$Tau)
rowMeans(qq$H %*% (qq$Gamma * qq$Tau))
plot(rowMeans(qq$H %*% (qq$Gamma * qq$Tau)))
ee
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee1
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee <- rowMeans(ee1)
ff <- rep(NA, 183)
for (i in 1:183) {
ff[i] <- sd(ee1[1, ])
}
ff
ee1
ee
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee <- rowMeans(ee1)
ee
ee1
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee <- rowMeans(ee1)
ff <- rep(NA, 183)
for (i in 1:183) {
ff[i] <- sd(ee1[i, ])
}
ff
ee1 <- diff(ee1)
ee1
ee <- rowMeans(ee1)
ff <- rep(NA, 183)
for (i in 1:183) {
ff[i] <- sd(ee1[i, ])
}
ee1 <- diff(ee1)
ee <- rowMeans(ee1)
ff <- rep(NA, 182)
for (i in 1:182) {
ff[i] <- sd(ee1[i, ])
}
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee1 <- diff(ee1)
ee <- rowMeans(ee1)
ee
plot(ee1)
plot(ee)
for (i in 1:182) {
ff[i] <- sd(ee1[i, ])
}
ff
ee1
ee1 / ff
ee1
ee1 / ff
plot(ee1 / ff)
plot(ee / ff)
ee / ff
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
rowMeans(ee1 > 0)
ee1 <- qq$H %*% (qq$Gamma * qq$Tau)
ee1 <- diff(ee1)
rowMeans(ee1 > 0)
plot(rowMeans(ee1 > 0))
1 - rowMeans(ee1 > 0)
plot(rowMeans(ee1 > 0))
1 - rowMeans(ee1 > 0)
p.adjust(1 - rowMeans(ee1 > 0))
p.adjust(1 - rowMeans(ee1 > 0))
p.adjust(1 - rowMeans(ee1 > 0), "BH")
plot(1 - rowMeans(ee1 > 0))
plot(p.adjust(1 - rowMeans(ee1 > 0), "BH"))
pp
pp[, 1]
pp$lim
pp$lim[, 2]
Y1 / pp$lim[, 2]
plot(Y1 / pp$lim[, 2])
plot(Y1 / pp$lim[, 2])
abline(abline = 1)
abline(h = 1)
source("~/Library/CloudStorage/Box-Box/2023 Summer/BayesianMonitoring/testcode.R")
Ph1MultipleTesting.Y01 <- function(model, bset,
FAP0 = 0.2, side = "right-sided",
nsim = 10000, interval = c(0.000001, 0.499999)) {
root.finding <- function(adj.alpha, ph1mat, FAP0, n, nsim, side = "right-sided") {
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2)
}
}
for (i in 1:nsim) {
sig[, i] <- (lim[, 1] < ph1mat[, i]) & (ph1mat[, i] < lim[, 2])
}
tmp <- mean(colSums(sig) == n)
dif <- tmp - (1 - FAP0)
##cat("dif:", dif, "\n")
return(dif)
}
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$mu0[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel])
}
tmpYyj <- yeojohnsontr(model$Z[, tmpsel] + model$Y, model$theta[tmpsel], 1e-32)
ph1mat[, i] <- simYXph1(matrix(tmpYyj, ncol = 1), matrix(model$Phi[, tmpsel], ncol = 1), Mu0,
model$sigma2[tmpsel],  model$theta[tmpsel],
1e-32, bset$leftcensoring, bset$lowerbound, bset$rounding)
}
adj.alpha <- uniroot(root.finding, interval, ph1mat = ph1mat, FAP0 = FAP0, n = n, nsim = nsim, side = side,
tol = 1e-6)$root
lim <- matrix(NA, nrow = n, ncol = 2)
sig <- matrix(NA, nrow = n, ncol = 1)
for (i in 1:n) {
if (side == "right-sided") {
lim[i, 1] <- -Inf
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha, na.rm = TRUE)
} else if (side == "left-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha, na.rm = TRUE)
lim[i, 2] <- infert
} else if (side == "two-sided") {
lim[i, 1] <- quantile(ph1mat[i, ], adj.alpha / 2, na.rm = TRUE)
lim[i, 2] <- quantile(ph1mat[i, ], 1 - adj.alpha / 2, na.rm = TRUE)
}
}
sig <- 1 - ((lim[, 1] < model$Y) & (model$Y < lim[, 2]))
list("grandsig" = sum(sig) > 0, "sig" = sig, "lim" = lim, "adj.alpha" = adj.alpha,
"Yph1" = ph1mat)
}
x <- rnorm(100)
y <- x + 2 + rnorm(1000)
x <- rnorm(100)
y <- x + 2 + rnorm(100)
y
x <- rnorm(100)
y <- 3 * x + 2 + rnorm(100)
y
plot(Y)
plot(y)
x <- rnorm(100)
xplus <- x
xminus <- -x
y <- 3 * xplus + 1.5 * xminus + 2 + rnorm(100)
xx <- cbind(xplus, xminus)
y
xxtxx <- t(xx) %*% xx
solve(xxtxx)
solve(t(x) %*% x)
backsolve(t(x) %*% x)
?backsolve
t(x) %*% x
t(xx) %*% xx
orderedLasso
Rcpp::compileAttributes()
roxygen2::roxygenise()
