# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' get a sample from inv gaussian distribution
#'
#' @param n is sample size.
#' @param mu is a parameter.
#' @param lambda is a paremter.
#' @export
#' @examples
#' rrinvgauss(10, 1, 1)
rrinvgauss <- function(n, mu, lambda) {
    .Call(`_BayesianLassoMonitoring_rrinvgauss`, n, mu, lambda)
}

#' get matrix V
#'
#' @param Y is a vector.
#' @param q is a number of lags.
#' @export
#' @examples
#' Y <- arima.sim(list(ar = 0.5), 100)
#' getV(Y, 10)
getV <- function(Y, q) {
    .Call(`_BayesianLassoMonitoring_getV`, Y, q)
}

#' get a sample from multivariate normal distribution
#'
#' @param Mean is a mean vector.
#' @param Sigma is a variance-covariance matrix.
#' @export
#' @examples
#' Mean <- rep(0, 5)
#' Sigma <- diag(nrow = 5)
#' rmvnorm(Mean, Sigma)
rmvnorm <- function(Mean, Sigma) {
    .Call(`_BayesianLassoMonitoring_rmvnorm`, Mean, Sigma)
}

#' get a sample from a normal distribution whose absolute observations are constrained.
#'
#' @param n is sample size.
#' @param a is the lower bound in absolute value.
#' @param b is the upper bound in absolute value.
#' @param mean is a mean.
#' @param sd is a standard deviation.
#' @export
#' @examples
#' rtwosegnorm(10, 1, 2, 0, 1)
rtwosegnorm <- function(n, a, b, mean, sd) {
    .Call(`_BayesianLassoMonitoring_rtwosegnorm`, n, a, b, mean, sd)
}

#' get a design matrix as that in MT
#'
#' @param T is length of a process.
#' @param q is the number of lags.
#' @export
#' @examples
#' getHMatMT(100, 5)
getHMatMT <- function(T, q) {
    .Call(`_BayesianLassoMonitoring_getHMatMT`, T, q)
}

#' get a design matrix for sustained shift
#'
#' @param T is length of a process.
#' @param q is the number of lags.
#' @param w is the subgroup size.
#' @export
#' @examples
#' getHMatSustained(100, 5, 1)
getHMatSustained <- function(T, q, w) {
    .Call(`_BayesianLassoMonitoring_getHMatSustained`, T, q, w)
}

#' get a design matrix for isolated shift
#'
#' @param T is length of a process.
#' @param q is the number of lags.
#' @param w is the subgroup size.
#' @export
#' @examples
#' getHMatIsolated(100, 5, 1)
getHMatIsolated <- function(T, q, w) {
    .Call(`_BayesianLassoMonitoring_getHMatIsolated`, T, q, w)
}

#' get a design matrix for gradual shift
#'
#' @param T is length of a process.
#' @param q is the number of lags.
#' @param w is the subgroup size.
#' @export
#' @examples
#' getHMatGradual(100, 5, 1)
getHMatGradual <- function(T, q, w) {
    .Call(`_BayesianLassoMonitoring_getHMatGradual`, T, q, w)
}

#' get a posterior sample using gibbs sampling for Random Flexible Level Shift Model
#'
#' @param Y is a vector.
#' @param q is the number of lags.
#' @param A is a given variance-covariance matrix in MT and regression for the coefficients for autoregressors.
#' @param a is a given shape of the prior gamma distribution for sigma2.
#' @param b is a given scale of the prior gamma distribution for sigma2.
#' @param alpha is a given shape of the prior gamma distribution for lambda2.
#' @param beta is a given scale of the prior gamma distribution for lambda22.
#' @param theta1 is a given shape1 of the prior beta distribution for the probability of Tau.
#' @param theta2 is a given shape2 of the prior beta distribution for the probability of Tau.
#' @param xi2 is a given variance of the prior normal distribution for shifts.
#' @param method is a choice of methods including MT(McCulloch-Tsay), regression, LASSO, ALASSO(Adaptive LASSO), MonoLASSO(LASSO with Monotonicity constrains), MonoALASSO(Adaptive LASSO with Monotonicity constrains).
#' @param bound0 is a lower bound of the methods with Monotonicity constrains.
#' @param boundqplus1 is  a upper bound of the methods with Monotonicity constrains.
#' @param nsim is the number of samples draw from MCMC.
#' @param by is the interval of systematic sampling for the draws from MCMC.
#' @param burnin is the length of burn-in period.
#' @param tol is the tolerance.
#' @param H is the design matrix for shifts.
#' @export
#' @examples
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#' 
#' result <- GibbsRFLSM(Y, q, diag(nrow = q), 0.1, 0.1, 0.1, 0.1, 
#' 1, 1, 0.1, "MonoALASSO", 0, Inf, 1000, 1, 100, 1e-10, H)
#' 
GibbsRFLSM <- function(Y, q, A, a, b, alpha, beta, theta1, theta2, xi2, method, bound0, boundqplus1, nsim, by, burnin, tol, H = NULL) {
    .Call(`_BayesianLassoMonitoring_GibbsRFLSM`, Y, q, A, a, b, alpha, beta, theta1, theta2, xi2, method, bound0, boundqplus1, nsim, by, burnin, tol, H)
}

